<!DOCTYPE html>

<html>

<head>
    <meta charset="UTF-8">
    <title>Pacman</title>
    </style>

</head>

<body>

    <canvas id="canvasOne"></canvas>

    <script type="text/javascript">
        //2 canvas variables used in drawing the canvas, theses are integral to the program
        var ctx;
        var canvas;

        //create the map array that will be processed to draw the map on screen

        var mapArray = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 5, 0, 4, 6, 6, 6, 6, 6, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 9, 6, 6, 6, 6, 9, 0, 4, 6, 6, 9, 0, 9, 6, 6, 6, 6, 9, 0, 0, 4, 6, 6, 5, 0, 0, 9, 6, 6, 6, 6, 9, 0, 9, 6, 6, 5, 0, 9, 6, 6, 6, 6, 9, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [3, 6, 5, 0, 9, 6, 6, 9, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 9, 0, 4, 8, 7, 8, 7, 5, 0, 9, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 9, 6, 6, 9, 0, 4, 6, 3],
          [3, 5, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 9, 6, 6, 6, 9, 2, 0, 2, 0, 7, 6, 6, 6, 6, 8, 0, 2, 0, 2, 9, 6, 6, 6, 9, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 4, 3],
          [3, 2, 2, 0, 9, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 9, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 8, 2, 0, 4, 6, 6, 6, 5, 0, 9, 6, 6, 6, 6, 5, 0, 9, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 9, 0, 9, 0, 4, 6, 6, 6, 6, 9, 0, 4, 6, 6, 6, 5, 0, 2, 7, 3],
          [9, 6, 8, 0, 2, 4, 6, 5, 2, 0, 2, 9, 6, 6, 9, 2, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 2, 0, 2, 9, 6, 6, 9, 2, 0, 2, 4, 6, 5, 2, 0, 7, 6, 9],
         [10, 3, 3, 0, 2, 2, 1, 2, 2, 0, 9, 6, 6, 6, 6, 8, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 0, 2, 0, 7, 6, 6, 6, 6, 9, 0, 2, 2, 1, 2, 2, 0, 3, 3, 10],
          [9, 6, 5, 0, 2, 2, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 2, 2, 0, 4, 6, 9],
          [3, 5, 2, 0, 2, 7, 6, 8, 2, 0, 4, 6, 5, 0, 4, 6, 6, 8, 0, 3, 3, 3, 3, 3, 6, 6, 6, 6, 8, 0, 7, 6, 6, 5, 0, 4, 6, 5, 0, 2, 7, 6, 8, 2, 0, 2, 4, 3],
          [3, 2, 2, 0, 7, 6, 6, 6, 8, 0, 2, 11, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 11, 2, 0, 7, 6, 6, 6, 8, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 4, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 5, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 2, 2, 0, 9, 0, 11, 0, 11, 0, 2, 2, 2, 0, 2, 0, 2, 11, 2, 0, 2, 4, 6, 6, 6, 6, 5, 2, 0, 2, 11, 2, 0, 2, 0, 2, 2, 2, 0, 11, 0, 11, 0, 9, 0, 2, 2, 3],
          [3, 2, 2, 0, 2, 0, 2, 0, 2, 0, 2, 12, 2, 0, 2, 0, 2, 12, 2, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 2, 12, 2, 0, 2, 0, 2, 12, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 3],
          [3, 2, 2, 0, 2, 0, 9, 0, 9, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 12, 0, 12, 0, 2, 0, 2, 2, 3],
          [3, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 3],
          [3, 2, 2, 0, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 3, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 3, 3]
      ];
        var mapArray1 = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 6, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 6, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 2, 3, 3, 2, 0, 2, 3, 3, 3, 2, 0, 2, 2, 0, 2, 3, 3, 3, 2, 0, 2, 3, 3, 2, 0, 2],
          [2, 0, 7, 6, 6, 8, 0, 7, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 8, 0, 7, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 6, 8, 0, 2, 2, 0, 7, 6, 6, 5, 4, 6, 6, 8, 0, 2, 2, 0, 7, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2],
          [7, 6, 6, 6, 6, 5, 0, 2, 7, 6, 6, 5, 3, 2, 2, 3, 4, 6, 6, 8, 2, 0, 4, 6, 6, 6, 6, 8],
          [3, 6, 6, 6, 5, 2, 0, 2, 4, 6, 6, 8, 3, 7, 8, 3, 7, 6, 6, 5, 2, 0, 2, 4, 6, 6, 6, 9],
          [3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3],
          [3, 6, 6, 6, 8, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 7, 6, 6, 6, 3],
          [9, 6, 6, 6, 6, 8, 0, 7, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 8, 0, 7, 6, 6, 6, 6, 3],
         [10, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 10],
          [9, 6, 6, 6, 6, 5, 0, 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 0, 4, 6, 6, 6, 6, 9],
          [3, 6, 6, 6, 5, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 4, 6, 6, 6, 3],
          [3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3],
          [3, 6, 6, 6, 8, 2, 0, 2, 2, 3, 4, 6, 6, 6, 6, 6, 6, 5, 3, 2, 2, 0, 2, 7, 6, 6, 6, 3],
          [9, 6, 6, 6, 6, 8, 0, 7, 8, 3, 7, 6, 6, 5, 4, 6, 6, 8, 3, 7, 8, 0, 7, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 6, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 6, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 5, 2, 0, 7, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 8, 0, 2, 4, 6, 8, 0, 2],
          [2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2],
          [1, 6, 5, 0, 2, 2, 0, 4, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 5, 0, 2, 2, 0, 4, 6, 2],
          [4, 6, 8, 0, 7, 8, 0, 2, 2, 0, 7, 6, 6, 5, 4, 6, 6, 8, 0, 2, 2, 0, 7, 8, 0, 7, 6, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 6, 6, 8, 7, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 8, 7, 6, 6, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8]
      ];

        //boundYSortArr will hold the processed objects that are formed from the 2-dim map array
        var boundYSortArr = [];

        //last press holds the last key pressed by the user, it needs to be global to keep it in scope
        var lastPress;
        //"not pressed" controls whether or not to use the last press or the current press
        var notPressed = false;
        //global score variable, is incremented when a user eats food
        var score = 0;

        //opnClsBool controls the motion of pacmans mouth movement
        //when 0 his mouth is open
        //when 1 his mouth is closed
        var opnClsBool = 0;


        //this is an object definition that takes in 2 values and stores them in an object
        //the values passed will be the x/y co-ordinates of another object
        function coOrds(x, y) {
            this.x = x;
            this.y = y;
        }


        //this is a character definition that stores position, speed and the type of character
        //position and speed are co-ords that store an x and y value
        //type should be just a string
        //currPos will be updated whenever the the algorithm finds the user's position
        function pacman(position, speed, type) {
            this.position = new coOrds(position.x, position.y);
            this.speed = new coOrds(speed.x, speed.y);
            this.type = type;
            this.currPos = 0;

            this.updatePacman = function () {
                this.position.x += this.speed.x;
                this.position.y += this.speed.y;
            }
        }

        function enemy(position, speed, type, imgY) {
            this.position = new coOrds(position.x, position.y);
            this.speed = new coOrds(speed.x, speed.y);
            this.type = type;
            this.currPos = null;
            this.img = new Image();
            this.img.src = "ImageMap.png";
            this.scareValue = 2;
            this.scareSpd = 20;
            //incrementing 20 to the x position grabs the next ghost face of that type
            this.imgXPos = 20;
            //incrementing 20 to the y position grabs the next ghost face of a different type
            this.imgYPos = imgY;
            this.storedYPos = imgY;
            this.imgH = 20;
            this.imgW = 20;
            this.sprW = 40;
            this.sprH = 40;
            this.leftEyes = 100;
            this.downEyes = 60;
            this.rightEyes = 120;
            this.upEyes = 20;
            this.scatterCounter = 7;
            this.scatterTurnOffNum = 0;
            //this counts every turn taken by the enemy
            //will be helpful in allowing the ghosts better movement
            //will stop need to recalculate path every turn
            this.enemyTurnCount = 0;

            this.recalcDirec = true;
            this.scaredMode = false;
            this.scatterMode = false;

            this.updateEyes = function () {
                if (this.speed.x < 0) {
                    this.imgXPos = this.leftEyes;
                } else if (this.speed.x > 0) {
                    this.imgXPos = this.rightEyes;
                } else if (this.speed.y > 0) {
                    this.imgXPos = this.downEyes;
                } else {
                    this.imgXPos = this.upEyes;
                }
            }

            this.scatterModeSwitcher = function () {
                if (score % 20 == 0) {
                    this.scatterMode = true;
                    this.scatterTurnOffNum = score + this.scatterCounter;
                } else if (score == this.scatterTurnOffNum) {
                    this.scatterMode = false;
                }
            }

            this.scaredSwitch = function () {
                /*if (this.scaredMode) {
                    this.imgYPos = 160;
                    this.scareSpd = -this.scareSpd;
                    if (this.enemyTurnCount - 1 == this.scareValue) {
                        this.imgXPos = 40;
                    }
                } else {
                    this.imgYPos = this.storedYPos;
                }*/
            }
            this.updateGhost = function (moveBool) {
                this.scaredSwitch();
                this.scatterModeSwitcher();
                if (moveBool == true) {
                    this.position.x += this.speed.x;
                    this.position.y += this.speed.y;
                }
                /*if (this.scaredMode) {
                    this.imgXPos += this.scareSpd;
                }*/
            }
        }

        //creating 3 character objects
        //the first 2 are enemies while the third is our hero pac
        var pinky = new enemy({
            x: 50,
            y: 50
        }, {
            x: 20,
            y: 0
        }, "enemy", 100);
        var angry = new enemy({
            x: 290,
            y: 370
        }, {
            x: 20,
            y: 0
        }, "enemy", 80);
        var pac = new pacman({
            x: 150,
            y: 210
        }, {
            x: 20,
            y: 0
        }, "pac");

        init();

        //the init function initialises the canvas as well as calling the functions to popAccBoundArr and the draw function
        function init() {
            //init canvas
            canvas = document.getElementById("canvasOne");
            canvas.height = 700;
            canvas.width = 1000;
            ctx = canvas.getContext("2d");
            popAccBoundArr();
            draw();
        }

        //the draw function draws the canvas
        function draw() {
            //resetting the canvas width clears the canvas for the next animation frame
            canvas.width = canvas.width;

            //this draws the canvas rectangle
            //and fills it with a dark blue colour
            ctx.beginPath()
            ctx.lineWidth = 2;
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.fill();
            ctx.closePath();

            //drawScore();
            //keypress events are handled here
            //the if statement checks the state of the notpressed boolean var
            //essentially it takes the current key pressed or the last key pressed
            //and passes that number to a move function that handles either presses
            if (notPressed == false) {
                document.addEventListener('keydown', function (event) {
                    move(event.keyCode);
                });
            } else if (notPressed == true) {
                move(lastPress);
            }

            //call 2 functions
            update();
            pcDirctnSwtch();
            drawScore();
        }

        function drawScore()
        {
          //score is drawn on the screen here
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.font = "30px Arial";
            ctx.fillText("Score: " + score, 30, 680);
            ctx.closePath();
   
        }
        //this fucntion takes in a number "press"
        //it checks for collisions and then alters the user speeds accordingly
        function move(press) {

            //key press handled here
            //checks collisions to the direction of pacman, 
            //if it's a valid place to move, speeds are altered
            //if it would cause a collision, the key will be saved for later and processed at the next available opportunity 
            //each press is effectively the same, only changing the needed speeds and checking the correct collisions

            //left key press
            if (press == 37 || press == 65) {
                if ((boundYSortArr[pac.currPos - 1].type == 3 || boundYSortArr[pac.currPos - 1].type == 0)) {
                    pac.speed.x = -20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //right key press
            else if (press == 39 || press == 68) {
                if ((boundYSortArr[pac.currPos + 1].type == 3 || boundYSortArr[pac.currPos + 1].type == 0)) {
                    pac.speed.x = 20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //down key press
            else if (press == 40 || press == 83) {
                if ((boundYSortArr[pac.currPos + mapArray[1].length].type == 3 || boundYSortArr[pac.currPos + mapArray[1].length].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = 20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //up key press
            else if (press == 38 || press == 87) {
                if ((boundYSortArr[pac.currPos - mapArray[1].length].type == 3 || boundYSortArr[pac.currPos - mapArray[1].length].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = -20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
        }

        //this function checks the speed of pacman
        //based on which speed is not 0, pacman will be drawn in a different direction
        //it calls pacDraw which takes in variables needed to draw the 3/4 circle that is pacman
        function pcDirctnSwtch() {
            //for pacman to face right
            if (pac.speed.x > 0) {
                pacDraw(1.8, 0.2);
                //for pacman to face to the left
            } else if (pac.speed.x < 0) {
                pacDraw(0.8, 1.2);
                //for pacman to face down
            } else if (pac.speed.y > 0) {
                pacDraw(0.2, 0.8)
                    //for pacman to face up
            } else if (pac.speed.y < 0) {
                pacDraw(1.2, 1.8);
            }
        }

        //this function is used to draw the main man
        //it takes in two variables that are multiplied by pi
        //essentially these variables control the direction pacman will face
        function pacDraw(pi1, pi2) {

            //this is a simple sound file that plays on a loop as pacman is drawn
            //it is taken straight from the original pacman game
            //I find it adds authenticity to my unauthorized clone of pacman
            var snd = new Audio("waka waka.mp3"); // buffers automatically when created
            snd.play();

            //draw all is called to draw the enemies and the map
            drawAll();

            //pacman is drawn
            ctx.beginPath();
            //pacman-yellow is set as the current fill style
            ctx.fillStyle = "rgb(255,238,0)";
            //opnClsBool controls the open close nature of pacmans mouth
            //when "on" it draws him open mouthed
            //when off it draws him closed mouth
            if (opnClsBool == 0) {
                //open mouth drawn
                ctx.arc(pac.position.x, pac.position.y, 15, pi1 * Math.PI, pi2 * Math.PI, true);
                ctx.lineTo(pac.position.x, pac.position.y);
                //sets the variable to 1 so that on next draw it will draw a full circle
                opnClsBool = 1;
            } else {
                //draw a full circle
                ctx.arc(pac.position.x, pac.position.y, 15, 2 * Math.PI, 0 * Math.PI, true);
                //set the variable to 0, effectively resetting pacman for the next draw to be open mouthed
                opnClsBool = 0;
            }

            //fills in the pacman object drawn to the canvas
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = "rgb(0,0,0)";

            //checks stae of opnClsBool
            //if only half way through the animation, redraw the pacman
            //or else redraw the canvas
            if (opnClsBool == 1) {
                setTimeout(function () {
                    pacDraw(pi1, pi2);
                }, 100)
            } else {
                setTimeout(draw, 300);
            }
        }

        //draw all simply calls draw functions to draw the rest of the objects
        function drawAll() {
            drawItems();
            enemyDraw(pinky);
            enemyDraw(angry);
        }


        //the update function calls other functions
        //these functions update the positions of the objects
        function update() {
            usrUpdate(pac);
            pinkGhostUpdate(pinky);
            redGhostUpdate(angry);
        }

        //usrUpdate takes in a character object
        //this object will always be pacman, but incase i would want to turn this into multiplayer at a later date
        //it takes the objcet rather than calling the object directly
        function usrUpdate(pac) {
            //possMove is the move that pacman wants to move to
            var possMove;
            //bool is just a generic boolean
            var bool;
            var pos, pos1;
            //determines which axis to alter
            //if ySpeed is 0 then xSpeed will have a value
            // and vice versa
            if (pac.speed.x != 0) {
                //chk the space to the left or right   
                //possmove is now calculated by doing the math that will occur if the move is good
                possMove = pac.position.x + pac.speed.x;
                //creating 2 objects, one with the current position and one with the coordinates of the next move
                pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                pos1 = {
                    y: pac.position.y,
                    x: possMove
                };

                //this else statement is effectively the same as above, the only difference 
                //is that it affects the y coordinates rather than the x coordinates
            } else if (pac.speed.y != 0) {
                //chk the space up or down   
                possMove = pac.position.y + pac.speed.y;
                pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                pos1 = {
                    y: possMove,
                    x: pac.position.x
                };
            }
            var mapPos = getMapPos(pos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to
            mapPos = setPossDifference(pos, pos1, mapPos);
            bool = chkMapNoType(mapPos, pos);

            if (bool) {
                pac.currPos = mapPos;
                //as long as the move is valid, it will update the position
                //the amount of the speed
                pac.updatePacman();
            }


            /*
                MAKES MORE SENSE LOGICALLY TO RETURN A TRUE IF 
                MOVE IS VALID
                
                CHANGE THIS!
            
            */
        }

        //this function loops through the array, it first finds the row of the current pacman position
        //it then searches through that column to find the row
        function getMapPos(curPos) {
            for (mapPos = 0; mapPos < boundYSortArr.length; ++mapPos) {
                //if the column is not correct, add a the length of a row to mapPos so that it gets the next row 
                if (curPos.y != boundYSortArr[mapPos].y) {
                    mapPos += mapArray[1].length - 1;
                    //to get to this part of the code, the search would have to find the row of pacman
                    //at this point, we search through this row to find it's exact location
                } else if (curPos.x == boundYSortArr[mapPos].x) {
                    //found currunt position at this point

                    //this returned position is returned to the parent function
                    return mapPos;
                }
            }
        }

        function setPossDifference(curPos, possPos, mapPos) {

            //posDiff checks x value and y value of curPos and possPos
            //it returns an 'x' if the x positions are different and a 'y' if the ys are different
            if (posDiff(curPos, possPos) == 'x') {
                //a check to see in what way are they different
                //if current is bigger than potential, then pacman wants to move right
                if (curPos.x > possPos.x) {
                    mapPos--;
                    //otherwise pacman wants to move left
                } else if (curPos.x < possPos.x) {
                    mapPos++;
                }
                //if 'x' wasnt return than it has to be the y that is different
                //in this case pacman wants to move up or down
            } else {
                //if up then pacman needs to shift the length of a row in the 2-dim array
                if (curPos.y > possPos.y) {
                    mapPos -= mapArray[0].length;
                    //otherwise he needs to shift back the same length as he is going down
                } else {
                    mapPos += mapArray[0].length;
                }
            }
            //at this point, the position that pacman wants to move in is known in the array
            //so that position is returned
            return mapPos;
        }

        //simple update score function
        //takes in a value and adds it to the score
        function updateScore(i) {
            score += i;
        }

        //simply changes the type of the block
        //takes in the position of the array and the new value on that position's type
        function changeMapType(pos, newT) {
            boundYSortArr[pos].type = newT;
        }


        //chkMapNoType takes in the current position, the value in the array of the possible move
        function chkMapNoType(i, curPos) {

            //checks are made to see if the possible move is a barrier  
            //i.e it's not a food or eaten food
            if ((boundYSortArr[i].type != 0) && (boundYSortArr[i].type != 3) && (boundYSortArr[i].type != 10)) {

                //if this is entered, then the move is invalid immediately
                //this is a barrier       

                /*
                    SWAP TRUE AND FALSE TO MAKE MORE SENSE
                */
                //a boolean is returned here stating that the position is invalid
                return false;
                //if the position is a food place it is valid for all characters to move to
            } else {
                //if pacman is the current character
                //the food will need to be eaten
                //the food state will need to change to eaten
                //and the score will need to be updated
                if (curPos.name == "pac") {
                    if (boundYSortArr[i].type == 0) {
                        boundYSortArr[i].type = 3;
                        changeMapType(i, 3);
                        updateScore(1);
                    }
                    //a check here tries to determine if the block is possibly a portal
                    //if it is then code needs to address that
                    if (boundYSortArr[i].type == 10) {
                        angry.recalcDirec = true;
                        pinky.recalcDirec = true;
                        //at this point, it is known that it is a portal
                        //we now need to see if it is a portal on the left or the right
                        //if on the left, we need to jump pacman to the far right hand side
                        if (boundYSortArr[i].x <= 30) {
                            pac.position.x = boundYSortArr[(i + mapArray[0].length) - 1].x;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i + mapArray[1].length - 2].type == 0) {
                                changeMapType(i + mapArray[1].length - 2, 3);
                                //score is updated also
                                updateScore(1);
                            }
                            //if the portal is not on the left then it is on the right
                            //the pacman's position will need to be changed
                        } else {
                            pac.position.x = 30;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i - mapArray[1].length + 3].type == 0) {
                                changeMapType(i - mapArray[1].length + 3, 3);
                                updateScore(1);
                            }
                        }
                    }
                }
            }

            //a boolean is returned here indicating that the position is valid
            return true;

        }

        //posDiff takes in two position objects
        //it will check if the x or the y positions are different
        function posDiff(curPos, possPos) {
            //x is different
            if (curPos.x != possPos.x) {
                return 'x';
            }
            //y is different
            else {
                return 'y';
            }
        }


        //this function is effectively the AI of the ghost
        function redGhostUpdate(en) {
            enNormalMode(en);
            var numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
            var mathDoer;

            if (en.scaredMode || en.scatterMode) {
                mathDoer = Math.max.apply(null, numList);
            } else {
                mathDoer = Math.min.apply(null, numList);
            }

            //calcEnMove will compare the distances with the min value
            //it will then move in that direction
            calcEnMove(numList[0], numList[1], numList[2], numList[3], mathDoer, en);
        }

        //this function is the AI of the pink ghost
        function pinkGhostUpdate(en) {
            enNormalMode(en);
            if (en.recalcDirec == true) {
                var numAhead = 80;
                var numList = [];
                var mathDoer;
                if (pac.speed.x > 0) {
                    if (pac.position.x + numAhead < 590) {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x + numAhead, pac.position.y, en);
                    } else {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                    }
                } else if (pac.speed.x < 0) {
                    if (pac.position.x - numAhead > 10) {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x - numAhead, pac.position.y, en);
                    } else {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                    }
                } else if (pac.speed.y > 0) {
                    if (pac.position.y + numAhead < 630) {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y + numAhead, en);
                    } else {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                    }
                } else {
                    if (pac.position.y - numAhead > 10) {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y - numAhead, en);
                    } else {
                        numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                    }
                }
                en.recalcDirec = false;

                if (en.scaredMode||en.scatterMode == true) {
                    mathDoer = Math.max.apply(null, numList);
                } else {
                    mathDoer = Math.min.apply(null, numList);
                }

                //calcEnMove will compare the distances with the min value
                //it will then move in that direction
                calcEnMove(numList[0], numList[1], numList[2], numList[3], mathDoer, en);
            }

        }

        function chkPossNewMoveAi(en) {
            if (en.speed.x > 0 || en.speed.x < 0) {
                if (boundYSortArr[en.currPos + mapArray[1].length].type == 3 || boundYSortArr[en.currPos + mapArray[1].length].type == 0 
                    || boundYSortArr[en.currPos - mapArray[1].length].type == 3 || boundYSortArr[en.currPos - mapArray[1].length].type == 0) {
                    return true;
                }
            } else if (en.speed.y > 0 || en.speed.y < 0) {
                if (boundYSortArr[en.currPos + 1].type == 3 || boundYSortArr[en.currPos + 1].type == 0 ||
                    boundYSortArr[en.currPos - 1].type == 3 || boundYSortArr[en.currPos - 1].type == 0) {
                    return true;
                }
            }
            return false;
        }

        function enNormalMode(en) {
            var possMove;
            var pos, pos1;

            if (en.speed.x != 0) {
                //chk the space to the left or right   
                possMove = en.position.x + en.speed.x;
                pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                pos1 = {
                    y: en.position.y,
                    x: possMove
                };
            } else if (en.speed.y != 0) {
                //chk the space up or down   
                possMove = en.position.y + en.speed.y;
                pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                pos1 = {
                    y: possMove,
                    x: en.position.x
                };
            }

            en.enemyTurnCount++;
            var mapPos = getMapPos(pos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to
            mapPos = setPossDifference(pos, pos1, mapPos);
            var bool = chkMapNoType(mapPos, pos);
            en.currPos = mapPos;
            if (chkPossNewMoveAi(en) == true) {
                //every 5th turn, or if the ghost is at a barrier or if the user changes directions
                //the ghost needs to recalculate its direction
                en.recalcDirec = true;
            }
            en.updateGhost(bool);
        }

        function enemyDraw(en) {
            ctx.beginPath();
            if (!en.scaredMode) {
                en.updateEyes();
            }
            ctx.drawImage(en.img, en.imgXPos, en.imgYPos, en.imgW, en.imgH, en.position.x - 20, en.position.y - 20, en.sprW, en.sprH);
            ctx.closePath();
        }

        //this function calculates which direction is faster than the others for the AI to reach pacman
        function enemyDistances(eX, eY, usrX, usrY, en) {
            //initializing the directions to infinity or 0 depending on whether scattermode is turned on
            //this will ensure that if they are not valid options
            //and so they will not be counted
            if (en.scatterMode==false&&en.scaredMode == false) {
                var numList = [Infinity, Infinity, Infinity, Infinity],
                    mathDoer = 0;
            } else {
                var numList = [0, 0, 0, 0],
                    mathDoer = Infinity;
            }
            //creating a currPos object that stores the current position of the ghost
            //it also stores the fact that it is an enemy

            var enCurrPos = {
                y: eY,
                x: eX
            };

            var positions = [{
                    y: eY - 20,
                    x: eX,
                    spdX: 0,
                    spdY: -20
            },
                {
                    y: eY + 20,
                    x: eX,
                    spdX: 0,
                    spdY: 20
            },
                {
                    y: eY,
                    x: eX - 20,
                    spdX: -20,
                    spdY: 0
            },
                {
                    y: eY,
                    x: eX + 20,
                    spdX: 20,
                    spdY: 0
            }];


            //here the possible positions are checked
            //using the distance of a line formula
            //the direction with the shortest distance will be chosen

            var mapPos = getMapPos(enCurrPos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to


            //mapHolder stores the mapPos in it's current form, mapPos will be altered and
            //and the original value of mapPos is needed to finish the calculations
            var mapHolder = mapPos;

            for (var counter = 0; counter < positions.length; ++counter) {
                mapPos = setPossDifference(enCurrPos, positions[counter], mapPos);
                if (chkMapNoType(mapPos, enCurrPos)) {
                    if ((en.speed.y != -positions[counter].spdY && en.speed.y != 0) || (en.speed.x != -positions[counter].spdX && en.speed.x != 0)) {
                        numList[counter] = dist(positions[counter].x, positions[counter].y + 20, usrX, usrY);
                    }
                }
                mapPos = mapHolder;
            }
            return (numList);
        }

        //basic distance of a line formula
        function dist(enX, enY, usrX, usrY) {
            var b1 = enX - usrX;
            b1 = Math.pow(b1, 2);
            var b2 = enY - usrY;
            b2 = Math.pow(b2, 2);
            return Math.sqrt(b1 + b2);
        }

        //checks which distance is min
        //whichever it is then it moves in that direction
        function calcEnMove(u, d, l, r, min, en) {
            if (u == min) {
                en.speed.x = 0;
                en.speed.y = -20;
            } else if (d == min) {
                en.speed.x = 0;
                en.speed.y = 20;
            } else if (r == min) {
                en.speed.x = 20;
                en.speed.y = 0;
            } else {
                en.speed.x = -20;
                en.speed.y = 0;
            }
        }

        //this function takes in the 2-dim array
        //and converts it to an object 1 dim array, containing x, y positions for each square in the grid
        //it also will contain the type of square that it is
        function popAccBoundArr() {
            var x = 20,
                y = 10;
            for (var i = 0; i < mapArray.length; ++i) {
                var inner = mapArray[i];
                y += 20;
                x = 30;
                for (var j = 0; j < inner.length; ++j) {
                    var outer = inner[j];
                    sortBoundaries(outer, x, y, boundYSortArr);
                    x += 20;
                }
            }
        }

        //this function creates a new array element with the passed in object parameters
        function sortBoundaries(type, x, y, arr) {
            arr.push({
                type, x, y
            });
        }

        //this function reads the object array of grid squares
        //it then draws an object in the correct grid based on it's type
        function drawItems() {
            for (var i = 0; i < boundYSortArr.length; ++i) {
                switch (boundYSortArr[i].type) {

                    //food
                case 0:
                    ctx.beginPath();
                    ctx.fillStyle = "rgb(255,169,164)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 3, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0;
                    ctx.fill();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.closePath();
                    break;

                    //circles
                case 1:
                    /* ctx.beginPath();
                     ctx.strokeStyle = "rgb(24,202,230)";
                     ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 10, 0, 2 * Math.PI, false);
                     ctx.lineWidth = 2;
                     ctx.stroke();
                     ctx.closePath();*/
                    break;

                    // verticle side
                case 2:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //eaten food
                case 3:
                    break;

                    //top left corner
                case 4:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //top right corner
                case 5:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //horizontal line
                case 6:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //bottom left Corner
                case 7:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //bottom right corner    
                case 8:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //end of line
                case 9:
                    break;

                    //portals
                case 10:
                    break;
                case 11:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 5);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 12:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 5);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                }

                ctx.strokeStyle = "rgb(0,0,0)";
            }
        }
    </script>

</body>

</html>