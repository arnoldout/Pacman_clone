<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pacman</title>
    </style>

</head>

<body>

    <canvas id="canvasOne"></canvas>

    <script type="text/javascript">
        //2 canvas variables used in drawing the canvas, theses are integral to the program
        var ctx;
        var canvas = document.getElementById("canvasOne");

        //create the map array that will be processed to draw the map on screen

        var mapArray = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2],
          [2, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 2],
          [2, 0, 9, 6, 6, 6, 6, 9, 0, 4, 6, 6, 9, 0, 9, 6, 6, 6, 6, 6, 3, 0, 4, 6, 6, 5, 0, 3, 6, 6, 6, 6, 6, 9, 0, 9, 6, 6, 5, 0, 9, 6, 6, 6, 6, 9, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [3, 6, 5, 0, 9, 6, 6, 9, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 9, 0, 4, 8, 2, 2, 7, 5, 0, 9, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 9, 6, 6, 9, 0, 4, 6, 3],
          [3, 5, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 9, 6, 6, 6, 9, 2, 0, 2, 0, 2, 6, 3, 3, 6, 2, 0, 2, 0, 2, 9, 6, 6, 6, 9, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 4, 3],
          [3, 2, 2, 0, 9, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 8, 0, 12, 0, 7, 6, 6, 6, 6, 8, 0, 12, 0, 7, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 9, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 8, 2, 0, 4, 6, 6, 6, 5, 0, 9, 6, 6, 6, 6, 5, 0, 9, 0, 4, 6, 6, 6, 16, 16, 16, 6, 6, 5, 0, 9, 0, 4, 6, 6, 6, 6, 9, 0, 4, 6, 6, 6, 5, 0, 2, 7, 3],
          [9, 6, 8, 0, 2, 4, 6, 5, 2, 0, 2, 9, 6, 6, 9, 2, 0, 2, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 2, 9, 6, 6, 9, 2, 0, 2, 4, 6, 5, 2, 0, 7, 6, 9],
         [10, 3, 3, 0, 2, 2, 1, 2, 2, 0, 9, 6, 6, 6, 6, 8, 0, 2, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 7, 6, 6, 6, 6, 9, 0, 2, 2, 1, 2, 2, 0, 3, 3, 10],
          [9, 6, 5, 0, 2, 2, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 2, 2, 0, 4, 6, 9],
          [3, 5, 2, 0, 2, 7, 6, 8, 2, 0, 4, 6, 5, 0, 4, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 5, 0, 4, 6, 5, 0, 2, 7, 6, 8, 2, 0, 2, 4, 3],
          [3, 2, 2, 0, 7, 6, 6, 6, 8, 0, 2, 11, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 11, 2, 0, 7, 6, 6, 6, 8, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 4, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 5, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 2, 2, 0, 9, 0, 11, 0, 11, 0, 2, 2, 2, 0, 2, 0, 2, 11, 2, 0, 2, 4, 6, 6, 6, 6, 5, 2, 0, 2, 11, 2, 0, 2, 0, 2, 2, 2, 0, 11, 0, 11, 0, 9, 0, 2, 2, 3],
          [3, 2, 2, 13, 2, 0, 2, 0, 2, 0, 2, 12, 2, 0, 2, 0, 2, 12, 2, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 2, 12, 2, 0, 2, 0, 2, 12, 2, 0, 2, 0, 2, 0, 2, 13, 2, 2, 3],
          [3, 2, 2, 0, 2, 0, 9, 0, 9, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 12, 0, 12, 0, 2, 0, 2, 2, 3],
          [3, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 3],
          [3, 2, 2, 0, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 0, 2, 2, 3],
          [3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3],
          [3, 3, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 3, 3]
      ];

        //this map is for a buggy bonus level
        //it is a remake of the original pacman game
        var mapArray1 = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 6, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 6, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 2, 3, 3, 2, 0, 2, 3, 3, 3, 2, 0, 2, 2, 0, 2, 3, 3, 3, 2, 0, 2, 3, 3, 2, 0, 2],
          [2, 0, 7, 6, 6, 8, 0, 7, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 8, 0, 7, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 6, 8, 0, 2, 2, 0, 7, 6, 6, 5, 4, 6, 6, 8, 0, 2, 2, 0, 7, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2],
          [7, 6, 6, 6, 6, 5, 0, 2, 7, 6, 6, 5, 3, 2, 2, 3, 4, 6, 6, 8, 2, 0, 4, 6, 6, 6, 6, 8],
          [3, 6, 6, 6, 5, 2, 0, 2, 4, 6, 6, 8, 3, 7, 8, 3, 7, 6, 6, 5, 2, 0, 2, 4, 6, 6, 6, 9],
          [3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3],
          [3, 6, 6, 6, 8, 2, 0, 2, 2, 3, 4, 6, 6, 16, 16, 16, 6, 5, 3, 2, 2, 0, 2, 7, 6, 6, 6, 3],
          [9, 6, 6, 6, 6, 8, 0, 7, 8, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 7, 8, 0, 7, 6, 6, 6, 6, 3],
         [10, 3, 3, 3, 3, 3, 0, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 0, 3, 3, 3, 3, 3, 10],
          [9, 6, 6, 6, 6, 5, 0, 4, 5, 3, 2, 3, 3, 3, 3, 3, 3, 2, 3, 4, 5, 0, 4, 6, 6, 6, 6, 9],
          [3, 6, 6, 6, 5, 2, 0, 2, 2, 3, 7, 6, 6, 6, 6, 6, 6, 8, 3, 2, 2, 0, 2, 4, 6, 6, 6, 3],
          [3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 2, 2, 3, 3, 3, 3],
          [3, 6, 6, 6, 8, 2, 0, 2, 2, 3, 4, 6, 6, 6, 6, 6, 6, 5, 3, 2, 2, 0, 2, 7, 6, 6, 6, 3],
          [9, 6, 6, 6, 6, 8, 0, 7, 8, 3, 7, 6, 6, 5, 4, 6, 6, 8, 3, 7, 8, 0, 7, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 5, 0, 4, 6, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 6, 5, 0, 4, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 5, 2, 0, 7, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 8, 0, 2, 4, 6, 8, 0, 2],
          [2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2],
          [1, 6, 5, 0, 2, 2, 0, 4, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 5, 0, 2, 2, 0, 4, 6, 2],
          [4, 6, 8, 0, 7, 8, 0, 2, 2, 0, 7, 6, 6, 5, 4, 6, 6, 8, 0, 2, 2, 0, 7, 8, 0, 7, 6, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 6, 6, 8, 7, 6, 6, 5, 0, 2, 2, 0, 4, 6, 6, 8, 7, 6, 6, 6, 6, 5, 0, 2],
          [2, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 7, 8, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8]
      ];


        //currentMap is used to enable me to make multiple different maps
        //I simply assign it to the map I want to use now
        //the rest of the code should be dynamic enough to adjust
        var currentMap;
        //boundYSortArr will hold the processed objects that are formed from the 2-dim map array
        var boundYSortArr = [];

        //this array will store the highscores of past users
        var highscores = [];

        //last press holds the last key pressed by the user, it needs to be global to keep it in scope
        var lastPress;
        //"not pressed" controls whether or not to use the last press or the current press
        var notPressed = false;
        //global score variable, is incremented when a user eats food
        var score = 0;

        //cuurGridScrVal is incremented when the grid is setup up
        //1 is added to its value whenever the setup search finds a food item
        //1 is taken away whenever the user eats food
        //when all the food is eaten, this number will be 0, the code will then reset the map, keeping the current score
        //effectively creating a new level
        var currGridScrVal = 0;

        //portal channel is used to stop the AI from going near the portal blocks
        var portalChannel;
        //opnClsBool controls the motion of pacmans mouth movement
        //when 0 his mouth is open
        //when 1 his mouth is closed
        var opnClsBool = 0;

        //strtGameCntrl is a global variable that is used to control the flow of the game between either menus and the game itself
        var strtGameCntrl = true;

        //objectStrtPos is an array that stores needed information for when the user loses a life
        //such as the AI's starting position, and the user's starting position
        var objectStrtPos = [];


        //deadloop is used in the dead pacman animation, as there are 12 sprites in that animation, deadloop iterates every
        //new frame, and when it hits 12, it is used to close the function and return to the game
        var deadLoop = 0;

        //this is an object definition that takes in 2 values and stores them in an object
        //the values passed will be the x/y co-ordinates of another object
        function coOrds(x, y) {
            this.x = x;
            this.y = y;
        }


        //this is a character definition that stores position, speed and the type of character
        //position and speed are co-ords that store an x and y value
        //type should be just a string
        //currPos will be updated whenever the the algorithm finds the user's position
        function pacman(position, speed, type) {
            this.position = new coOrds(position.x, position.y);
            this.speed = new coOrds(speed.x, speed.y);
            //type is a string used to differentiate between a pacman and an enemy
            this.type = type;
            this.currPos = 0;
            //inGame is a boolean used to see if pacman is in the game at the current time or not
            this.inGame = true;
            //lives keeps the number of retries (or "lives") the user has left until the user loses
            this.lives = 3;
            //stunned is used to control the canvas when the user dies
            //without this control, the code continues to draw the game, calculating everything while also killing the game
            //this looks weird and is not the effect i'm looking for
            this.stunned = false;
            //dead is turned on when all lives are lost
            //it will trigger the highscore screen when true
            this.dead = false;
            //img is linked to my spriteMap
            this.img = new Image();
            this.img.src = "ImageMap.png";


            //pacman moves when he's alive
            //updating his position by way of his speed, which is calculated elsewhere
            this.updatePacman = function () {
                    if (this.dead == false) {
                        this.position.x += this.speed.x;
                        this.position.y += this.speed.y;
                    }
                }
                //reset is called when a new game is started and also when the user loses a life
                //it resets the properties needed from the start of the game
            this.reset = function () {
                    //if reset is called and pacman is not dead, a life will be lost
                    if (!this.dead) {
                        this.lives--;
                        //this sets dead to true should all lives be lost
                        if (this.lives <= 0) {
                            this.dead = true;
                        }
                        //afterDeathReset is called here, which resets rest of the game
                        afterDeathReset(objectStrtPos[0], objectStrtPos[1], objectStrtPos[2], objectStrtPos[3]);
                    } else {
                        //if reset is called and pacman is already dead, various needed variables will be reset
                        this.position = new coOrds(position.x, position.y);
                        this.speed = new coOrds(speed.x, speed.y);
                        this.type = type;
                        this.currPos = 0;

                        this.lives = 3;
                        this.stunned = false;
                        this.dead = false;
                    }
                }
                //this simply draws an image of a life for every life that is left
            this.drawLives = function () {

                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.font = "30px Arial";
                ctx.fillText("Lives: ", 400, 680);
                ctx.closePath();
                for (var liveCount = 0; liveCount < this.lives; liveCount++) {
                    ctx.drawImage(this.img, 80, 160, 20, 20, 480 + (liveCount * 20), 650, 40, 40);
                }
            }
        }

        //Enemy is used to create a new enemy object, such as a new ghost
        function enemy(position, speed, type, imgY) {
            //position is the x and y co-ordinates of this ghost
            this.position = new coOrds(position.x, position.y);
            //speed is used to control the ghost's movements
            this.speed = new coOrds(speed.x, speed.y);
            //startingPos is the position that the ghost will move to when it is acive but not in game
            //it will be a position slightly outside of it's cage
            //when it hits this position, inGame will be set to true, and the ghost will start to move to pacman instead
            this.strtingPos = new coOrds(510, 210);
            //type is an identifier for the type of object in use i.e. enemy or pacman
            this.type = type;
            //currPos is updated every move, it will store the grid position of the enemy
            this.currPos = null;
            //this is the sprite map image
            this.img = new Image();
            this.img.src = "ImageMap.png";
            //scareValue triggers the ghost to turn blue and white when scared
            this.scareValue = 2;
            //this is the value used to change the sprite from blue to white when scared
            this.scareSpd = 20;
            //incrementing 20 to the x position grabs the next ghost face of that type
            this.imgXPos = 20;

            //these variables are used to control the sprite position
            this.imgYPos = imgY;
            this.storedYPos = imgY;
            this.imgH = 20;
            this.imgW = 20;
            this.sprW = 40;
            this.sprH = 40;
            this.leftEyes = 100;
            this.downEyes = 60;
            this.rightEyes = 120;
            this.upEyes = 20;
            this.scatterCounter = 7;
            this.scatterTurnOffNum = 0;
            //this counts every turn taken by the enemy
            //will be helpful in allowing the ghosts better movement
            //will stop need to recalculate path every turn

            this.enemyTurnCount = 0;
            this.scareConst = 40;
            this.scareAdapt = 0;

            //when true, the AI will recalculate their direction
            //this is only triggered when there is a new possible move for it, or if it is colliding with another ghost
            //the AI will never be able to go back on itself unless it is in scared or scatter mode
            this.recalcDirec = true;
            //these vars are self explantory
            //when any of the "Modes" are switched on, the ghost will have different behaviour
            this.scaredMode = false;
            this.deadMode = false;
            this.scatterMode = false;

            //these vars are used to control the ghost as it leaves the cage
            //instead of randomly moving around the cage, it is given a co-ordinate to move toward
            //located just outside of the cage, when it hits that position, inGame is set to true
            //isActive is triggered when the user has predetermind score
            this.inGame = false;
            this.isActive = false;

            //this resets lots of variables when called
            this.reset = function () {
                this.scatterCounter = 7;
                this.scatterTurnOffNum = 0;
                this.enemyTurnCount = 0;
                this.recalcDirec = true;
                this.scaredMode = false;
                this.scatterMode = false;
                this.inGame = false;
                this.isActive = false;
                this.scareValue = 2;
                this.scareSpd = 20;
                this.currPos = null;
                this.deadMode = false;
            }

            //this changes the sprite depending on it's speed
            //it gives the illusion that the ghost is looking in the direction it is moving toward
            this.updateEyes = function () {
                if (!this.deadMode) {
                    if (this.speed.x < 0) {
                        this.imgXPos = this.leftEyes;
                    } else if (this.speed.x > 0) {
                        this.imgXPos = this.rightEyes;
                    } else if (this.speed.y > 0) {
                        this.imgXPos = this.downEyes;
                    } else {
                        this.imgXPos = this.upEyes;
                    }
                }
            }

            //turns scatter mode on or off depending on certain variables' values
            /*
                scatter mode is used to make the enemy move away from the user
                it allows for a bit of breathing room at the start
                and that breathing rooom shrinks the longer the user plays
                for
                
                Further down in the code I check the scattermode value
                when checked if true, the enemy moves away from the user by selecting the 
                longest line distance from the user, rather than the shortest
            */
            this.scatterModeSwitcher = function () {
                //to turn scatter mode on, the enemy has to have moved 20 places, and the scatter controller cant be greater than 4
                //the enemy also needs to be chasing the enemy
                if (this.enemyTurnCount % 20 == 0 && this.scatterCounter > 4 && this.inGame) {
                    this.scatterMode = true;
                    //this calculates the point at which the scattermode is turned off
                    this.scatterTurnOffNum = score + this.scatterCounter;
                    //once the enemy has moved that ammount of moves, scatter mode is turned off
                } else if (this.enemyTurnCount == this.scatterTurnOffNum) {
                    this.scatterMode = false;
                }
                //the scatter controller is decremented every 2nd scatterMode
                //this allows for shorter scattermodes as the game progresses
                //effectively making the game harder the longer the user plays
                if (this.enemyTurnCount % 40 == 0) {
                    this.scatterCounter--;
                }
            }

            //scared switch controls the sprite used when in scared mode
            /*
                Scared mode occurs when pacman eats some superfood
                the ghosts instantly become terrified of pacman and try to run away from him
                as effectively as they possibly can
                
                If a ghost collides with pacman when in scared mode, the ghost's mode turns to deadMode
            
            */
            this.scaredSwitch = function () {
                    //since scaredMode and deadMode are linked
                    //i check their values, and provided scaredMode returns true and 
                    //deadMode returns false, the ghost's sprite is switched between blue and white
                    if (this.scaredMode && this.deadMode == false) {
                        //simple initilaiser to see if this is the first time that 
                        //the enemy has been in the current scaredmode
                        if (this.enemyTurnCount + 1 == this.scareValue) {
                            //if true then the sprite is initilaised to 40 on the x value
                            //this denotes the column change needed to occur to change that sprite
                            this.imgXPos = 40;

                        }
                        //the imgYPos needs to be 160 always when in scared mode as that is the row with the scared faces sprites
                        this.imgYPos = 160;
                        //scareSpd will change every turn, when it changes
                        //scareSpd becomes the value of the blue or white white sprite
                        this.scareSpd = -this.scareSpd;

                        //scareAdapt keeps a count of the time the enemy stays in scaredMode
                        //it "Adapts" if the user hits another superfood while the enemy is still in scaredMode
                        //then if the enemy has more turns than the adapted Scare number, it will exit scaredMode and go on the attack
                        if (this.enemyTurnCount > this.scareAdapt) {
                            this.updateScaredMode(false);
                            this.updateGhost();
                        }
                        //if its not in scareMode, then it might be dead
                        //if its dead, the ghost needs to use the dead sprite
                        //the sprite x and y positions are thus altered
                    } else if (this.deadMode) {
                        this.scaredMode = false;
                        this.imgXPos = 40;
                        this.imgYPos = 200;
                        //if at this point, the enemy is neither dead nor scared, the used variables need to reset
                        //imgYPos is reset to the normal ghost sprite
                        //enemyTurnCount is reset as i do not need to keep track of the ghost's movements if its in normal mode
                        //and scareSpd is reset to 20 as this is the value of the scared sprite initially
                    } else {
                        this.imgYPos = this.storedYPos;
                        this.enemyTurnCount = 0;
                        this.scareSpd = 20;
                    }
                }
                //update ghost checks that the ghost has been activated, then checks for any possible modes that might be on
                //moveBool controls wether the ghosts can move or not
                //if it is true then the ghost will naturally move in the direction it's speed dictates
            this.updateGhost = function (moveBool) {
                    if (this.isActive) {
                        this.scaredSwitch();
                        this.scatterModeSwitcher();
                        if (moveBool == true) {
                            this.position.x += this.speed.x;
                            this.position.y += this.speed.y;
                        }
                        //scareSpd as stated above, controls the scaredmode sprites
                        //every turn in scared mode, the ghost will switch between blue and black because of this line
                        if (this.scaredMode) {
                            this.imgXPos += this.scareSpd;
                        }
                    }
                }
                //updateScaredMode is called when a new superfood is eaten
                //scaredMode is set to modeBool, and scareAdapt gets the value of scareConst added to it
            this.updateScaredMode = function (modeBool) {
                if (this.inGame&&this.deadMode==false) {
                    this.scaredMode = modeBool;
                    this.scareAdapt += this.scareConst;
                }
            }
        }

        //creating 3 character objects
        //the first 2 are enemies while the third is our hero pac
        var pinky = new enemy({
            x: 450,
            y: 270
        }, {
            x: 20,
            y: 0
        }, "enemy", 100);
        var angry = new enemy({
            x: 530,
            y: 270
        }, {
            x: -20,
            y: 0
        }, "enemy", 80);
        var pac = new pacman({
            x: 750,
            y: 210
        }, {
            x: 20,
            y: 0
        }, "pac");

        function homeScreen() {

            //homescreen is the opening screen the user sees when they open the game
            //it consists of a logo, some animated text and moving ghosts
            canvas.height = 700;
            canvas.width = 1000;
            ctx = canvas.getContext("2d");
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            //menu ghosts are setup and initilaised, they will move across the bottom of the screen
            var menuPinky = new enemy({
                x: 800,
                y: 450
            }, {
                x: -20,
                y: 0
            }, "enemy", 80);

            var menuAngry = new enemy({
                x: 200,
                y: 550
            }, {
                x: 20,
                y: 0
            }, "enemy", 100);


            //imageObj is the logo image shown
            var imageObj = new Image();
            imageObj.src = "PacLogo.png";

            //when the image is loaded into memory, it is shown to the screen
            imageObj.onload = function () {
                    ctx.drawImage(imageObj, 190, 50);
                }
                //the words click too start are displayed in the center of the screen
            ctx.beginPath();
            ctx.fillStyle = 'pink';
            ctx.textAlign = 'center';
            ctx.font = "30px Arial";
            ctx.fillText("Click to start", 475, 380);
            ctx.closePath();
            var pX = menuPinky.speed.x;
            var aX = menuAngry.speed.x;
            var num = 1;

            dotAnim(menuPinky, menuAngry, pX, aX, num);

        }

        //dotAnim handles the animation needed for the homeScreen
        //namely that of the animated text and it also calls the ghost movement function

        /*
            the two "menu" parameters are ghosts, the pX and aX are their current speeds
            num controls which dot on the menu to change the colour of
        */
        function dotAnim(menuPinky, menuAngry, pX, aX, num) {
            //due to stack issues caused by moving between menus and the game
            //strtGameCntrl rejects access to this function should the user have clicked the screen
            //without this, the game will continue to print the ghosts and dots briefly while they are in stack at the same time as the game
            if (strtGameCntrl == true) {
                //the ghosts aremoved
                pX = menuEnMv(pX, menuPinky);
                //the ghosts are drawn
                enemyDraw(menuPinky);
                aX = menuEnMv(aX, menuAngry);
                enemyDraw(menuAngry);
                //the previous animated dot is emptied
                //and a black square is filled in in its place
                ctx.clearRect(578 + (17 * num), 375, 5, 5);
                ctx.fillStyle = 'black';
                ctx.fillRect(568, 370, 100, 20);

                //three dots are drawn after the text written in homeScreen() 
                ctx.beginPath();
                ctx.fillStyle = 'pink';
                ctx.textAlign = 'center';
                ctx.font = "30px Arial";
                ctx.fillText(". . .", 598, 380);
                ctx.closePath();

                //the current dot is painted white, in contrast to the pink dots, it creates a fluid animation 
                //like a loading screen
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = "30px Arial";
                ctx.fillText(".", 581 + (17 * num), 380);
                ctx.closePath();
                num++;
                //recursively calling the dotAnim function every 150 milliseconds
                setTimeout(function () {
                    dotAnim(menuPinky, menuAngry, pX, aX, num)
                }, 150);
            }
            if (num == 3) {
                num = 0;
            }
        }

        homeScreen();

        //click event, where if the game is on a menu screen, it listens for a click and activates the game
        canvas.addEventListener('click', function (event) {
            if (strtGameCntrl == true) {
                strtGameCntrl = false;
                //if pac is alive then the game is starting from an initial state, so init needs to be called
                if (!pac.dead) {
                    canvas.width = canvas.width;
                    init(mapArray, {
                        x: 450,
                        y: 270
                    }, {
                        x: 530,
                        y: 270
                    }, {
                        x: 750,
                        y: 210
                    }, {
                        x: 510,
                        y: 210
                    }, 2);
                    //as opposed to if it is starting from the highscores screen where pacman is dead
                } else {
                    restartGame(objectStrtPos[0], objectStrtPos[1], objectStrtPos[2], objectStrtPos[3], mapArray, 2);
                }
            }
        }, false);


        //init(mapArray1, {x:310, y:310}, {x:350, y:330}, {x:250, y:250}, {x:350, y:270}, 5);
        //the init function initialises the canvas as well as calling the functions to popAccBoundArr and the draw function
        function init(currentMapVal, pinkyPos, angryPos, pacPos, strtPos, corridorDist) {
            //init canvas
            currentMap = currentMapVal;
            pac.stunned = false;
            //initialising the objectStrtPos array with the reset positions needed to put ghosts and pacman back to their intended positions upon game state change
            objectStrtPos.push(new coOrds(pinkyPos.x, pinkyPos.y));
            objectStrtPos.push(new coOrds(angryPos.x, angryPos.y));
            objectStrtPos.push(new coOrds(pacPos.x, pacPos.y));
            objectStrtPos.push(new coOrds(strtPos.x, strtPos.y));

            //the grid is setup here
            boundYSortArr = [];
            portalChannel = corridorDist;
            //the map is read. and it is converted to a single dim array of integers
            popAccBoundArr();
            //draw is called which controls most of the game, it calls most functions, and draws everything to the screen
            draw();
        }

        function drawDeadPacman() {

            //this draws the canvas rectangle
            //and fills it with a dark blue colour
            //it then draws the current deadPac image
            canvas.height = canvas.height;
            ctx.beginPath()
            ctx.lineWidth = 2;
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(0,0,0)";
            ctx.fill();
            ctx.closePath()
            drawItems();
            ctx.drawImage(pac.img, 0 + (20 * deadLoop), 240, 20, 20, pac.position.x - 20, pac.position.y - 20, 40, 40);
            deadLoop++;
        }

        function afterDeathReset(pinkyPos, angryPos, pacPos, strtPos) {
            //this function loops through the dead pacman sprites
            //when its done, it resets some properties and sends the game back into playing mode
            drawDeadPacman();
            //pac.stunned is used to control the stack when using specialized 
            pac.stunned = true;
            //setInterval works like setTimeout but with a loop built into its functionality
            //with setInterval the code iterates indefinatly until the clearInterval is called
            var intrvl = setInterval(function () {
                drawDeadPacman();

                //check on the state of the animation, and the state of pacman
                //if the animation and pac is still alive, required variables are reset
                if (deadLoop > 12 && pac.dead == false && pac.stunned == true) {
                    pac.stunned = false;

                    pac.position.x = pacPos.x;
                    pac.position.y = pacPos.y;
                    pinky.position.x = pinkyPos.x;
                    pinky.position.y = pinkyPos.y;
                    pinky.strtingPos = strtPos;
                    angry.position.x = angryPos.x;
                    angry.position.y = angryPos.y;
                    angry.strtingPos.x = strtPos.x;
                    angry.strtingPos.y = strtPos.y;
                    pac.speed.y = 0;
                    pac.speed.x = 20;
                    angry.reset();
                    pinky.reset();
                    draw();
                    deadLoop = 0;
                    clearInterval(intrvl);
                    //if the user is dead after the animation is complete, then the highscore code needs to be called
                } else if (pac.dead && deadLoop > 12) {
                    canvas.width = 1000;
                    setupLS();
                    clearInterval(intrvl);
                }
            }, 100);
        }

        //this function is called when the game wants to restart
        //used primarily when moving from highscore to in game
        //and also when the game runs out of food and needs to get some more
        function restartGame(pinkyPos, angryPos, pacPos, strtPos, nMapArr, corridorDis) {
            if (currentMap != nMapArr) {
                currentMap = nMapArr;
                portalChannel = corridorDis;
            }

            deadLoop = 0;
            pac.position.x = pacPos.x;
            pac.position.y = pacPos.y;
            pinky.position.x = pinkyPos.x;
            pinky.position.y = pinkyPos.y;
            pinky.strtingPos = strtPos;
            angry.position.x = angryPos.x;
            angry.position.y = angryPos.y;
            angry.strtingPos.x = strtPos.x;
            angry.strtingPos.y = strtPos.y;
            pinky.reset();
            angry.reset();
            //if restart is called and pac is dead, then the score and pacman is reset
            if (pac.dead) {
                score = 0;
                pac.reset();
            }
            //emptying the objectStrtPos array and calling init which will repopulate objectStrtPos with new values
            objectStrtPos = [];
            init(nMapArr, pinkyPos, angryPos, pacPos, strtPos, corridorDis);
        }

        //the draw function draws the canvas
        function draw() {
            if (!pac.stunned) {

                //this draws the canvas rectangle
                //and fills it with a dark blue colour
                canvas.height = canvas.height;
                ctx.beginPath()
                ctx.lineWidth = 2;
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgb(0,0,0)";
                ctx.fill();
                ctx.closePath();

                //keypress events are handled here
                //the if statement checks the state of the notpressed boolean var
                //essentially it takes the current key pressed or the last key pressed
                //and passes that number to a move function that handles either presses
                if (notPressed == false) {
                    document.addEventListener('keydown', function (event) {
                        move(event.keyCode);
                    });
                } else if (notPressed == true) {
                    move(lastPress);
                }

                //call 3 functions
                update();
                pcDirctnSwtch();
                drawScore();


                //code for highly buggy bonus level
                //lots of unexpected bugs occur when using this map
                //for now I will stick to the map i created 
                //possibly in the future I may implement this
                /* if (score == 3000) {
                     canvas.width = 600;
                     score++;
                     boundYSortArr = [];
                     popAccBoundArr();
                     objectStrtPos = [];
                     pac.stunned = true;
                     currGridScrVal = 0;
                     setTimeout(function () {
                         restartGame({
                             x: 230,
                             y: 310
                         }, {
                             x: 250,
                             y: 350
                         }, {
                             x: 250,
                             y: 250
                         }, {
                             x: 230,
                             y: 250
                         }, mapArray1, 5)
                     }, 500);
                 }*/
            }
        }

        function drawScore() {
            //score is drawn on the screen here
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.font = "30px Arial";
            ctx.fillText("Score: " + score, 100, 680);
            ctx.closePath();

        }
        //this fucntion takes in a number "press"
        //it checks for collisions and then alters the user speeds accordingly
        function move(press) {
            if (!pac.dead) {
                //key press handled here
                //checks collisions to the direction of pacman, 
                //if it's a valid place to move, speeds are altered
                //if it would cause a collision, the key will be saved for later and processed at the next available opportunity 
                //each press is effectively the same, only changing the needed speeds and checking the correct collisions

                //left key press
                if (press == 37 || press == 65) {
                    if ((boundYSortArr[pac.currPos - 1].type == 3 || boundYSortArr[pac.currPos - 1].type == 0 || boundYSortArr[pac.currPos - 1].type == 13)) {
                        pac.speed.x = -20;
                        pac.speed.y = 0;
                        notPressed = false
                    } else {
                        lastPress = press;
                        notPressed = true;
                    }
                }
                //right key press
                else if (press == 39 || press == 68) {
                    if ((boundYSortArr[pac.currPos + 1].type == 3 || boundYSortArr[pac.currPos + 1].type == 0 || boundYSortArr[pac.currPos + 1].type == 13)) {
                        pac.speed.x = 20;
                        pac.speed.y = 0;
                        notPressed = false
                    } else {
                        lastPress = press;
                        notPressed = true;
                    }
                }
                //down key press
                else if (press == 40 || press == 83) {
                    if ((boundYSortArr[pac.currPos + currentMap[1].length].type == 3 || boundYSortArr[pac.currPos + currentMap[1].length].type == 0 || boundYSortArr[pac.currPos + currentMap[1].length].type == 13)) {
                        pac.speed.x = 0;
                        pac.speed.y = 20;
                        notPressed = false
                    } else {
                        lastPress = press;
                        notPressed = true;
                    }
                }
                //up key press
                else if (press == 38 || press == 87) {
                    if ((boundYSortArr[pac.currPos - currentMap[1].length].type == 3 || boundYSortArr[pac.currPos - currentMap[1].length].type == 0 || boundYSortArr[pac.currPos - currentMap[1].length].type == 13)) {
                        pac.speed.x = 0;
                        pac.speed.y = -20;
                        notPressed = false
                    } else {
                        lastPress = press;
                        notPressed = true;
                    }
                }
            }
        }

        //this function checks the speed of pacman
        //based on which speed is not 0, pacman will be drawn in a different direction
        //it calls pacDraw which takes in variables needed to draw the 3/4 circle that is pacman
        function pcDirctnSwtch() {
            //for pacman to face right
            if (pac.speed.x > 0) {
                pacDraw(1.8, 0.2);
                //for pacman to face to the left
            } else if (pac.speed.x < 0) {
                pacDraw(0.8, 1.2);
                //for pacman to face down
            } else if (pac.speed.y > 0) {
                pacDraw(0.2, 0.8)
                    //for pacman to face up
            } else if (pac.speed.y < 0) {
                pacDraw(1.2, 1.8);
            }
        }

        //this function is used to draw the main man
        //it takes in two variables that are multiplied by pi
        //essentially these variables control the direction pacman will face
        function pacDraw(pi1, pi2) {
            
            //Code for unused soundfile to play the traditional "Waka Waka" sound the original pacman made.
            //I chose against using it for now as getting it to synchronize with the movement of pacman was a nightmare
            //for now it is simply easier to play the silent game
            
            //var snd = new Audio("waka waka.mp3"); // buffers automatically when created
            //snd.play();

            //draw all is called to draw the enemies and the map
            drawAll();

            //pacman is drawn
            ctx.beginPath();
            //pacman-yellow is set as the current fill style
            ctx.fillStyle = "rgb(255,238,0)";
            //opnClsBool controls the open close nature of pacmans mouth
            //when "on" it draws him open mouthed
            //when off it draws him closed mouth
            if (opnClsBool == 0) {
                //open mouth drawn
                ctx.arc(pac.position.x, pac.position.y, 15, pi1 * Math.PI, pi2 * Math.PI, true);
                ctx.lineTo(pac.position.x, pac.position.y);
                //sets the variable to 1 so that on next draw it will draw a full circle
                opnClsBool = 1;
            } else {
                //draw a full circle
                ctx.arc(pac.position.x, pac.position.y, 15, 2 * Math.PI, 0 * Math.PI, true);
                //set the variable to 0, effectively resetting pacman for the next draw to be open mouthed
                opnClsBool = 0;
            }

            //fills in the pacman object drawn to the canvas
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = "rgb(0,0,0)";

            //checks stae of opnClsBool
            //if only half way through the animation, redraw the pacman
            //or else redraw the canvas
            if (opnClsBool == 1) {
                setTimeout(function () {
                    pacDraw(pi1, pi2);
                }, 100);
            } else {
                if (!pac.stunned) {
                    setTimeout(draw, 150);
                }
            }
        }

        //draw all simply calls draw functions to draw the rest of the objects
        function drawAll() {
            drawItems();
            enemyDraw(pinky);
            enemyDraw(angry);
        }


        //the update function calls other functions
        //these functions update the positions of the objects
        function update() {
            usrUpdate(pac);
            pinkGhostUpdate(pinky);
            redGhostUpdate(angry);
        }

        //usrUpdate takes in a character object
        //this object will always be pacman, but incase i would want to turn this into multiplayer at a later date
        //it takes the objcet rather than calling the object directly
        function usrUpdate(pac) {
            //possMove is the move that pacman wants to move to
            var possMove;
            //bool is just a generic boolean
            var bool;
            var pos, pos1;
            //determines which axis to alter
            //if ySpeed is 0 then xSpeed will have a value
            // and vice versa
            if (pac.speed.x != 0) {
                //chk the space to the left or right   
                //possmove is now calculated by doing the math that will occur if the move is good
                possMove = pac.position.x + pac.speed.x;
                //creating 2 objects, one with the current position and one with the coordinates of the next move
                pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                pos1 = {
                    y: pac.position.y,
                    x: possMove
                };

                //this else statement is effectively the same as above, the only difference 
                //is that it affects the y coordinates rather than the x coordinates
            } else if (pac.speed.y != 0) {
                //chk the space up or down   
                possMove = pac.position.y + pac.speed.y;
                pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                pos1 = {
                    y: possMove,
                    x: pac.position.x
                };
            }
            var mapPos = getMapPos(pos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to
            mapPos = setPossDifference(pos, pos1, mapPos);
            bool = chkMapNoType(mapPos, pos, pac);

            if (bool) {
                pac.currPos = mapPos;
                //as long as the move is valid, it will update the position
                //the amount of the speed
                pac.updatePacman();
            }

        }

        //this function loops through the array, it first finds the row of the current pacman position
        //it then searches through that column to find the row
        function getMapPos(curPos) {
            for (mapPos = 0; mapPos < boundYSortArr.length; ++mapPos) {
                //if the column is not correct, add a the length of a row to mapPos so that it gets the next row 
                if (curPos.y != boundYSortArr[mapPos].y) {
                    mapPos += currentMap[1].length - 1;
                    //to get to this part of the code, the search would have to find the row of pacman
                    //at this point, we search through this row to find it's exact location
                } else if (curPos.x == boundYSortArr[mapPos].x) {
                    //found currunt position at this point

                    //this returned position is returned to the parent function
                    return mapPos;
                }
            }
        }

        function setPossDifference(curPos, possPos, mapPos) {

            //posDiff checks x value and y value of curPos and possPos
            //it returns an 'x' if the x positions are different and a 'y' if the ys are different
            if (posDiff(curPos, possPos) == 'x') {
                //a check to see in what way are they different
                //if current is bigger than potential, then pacman wants to move right
                if (curPos.x > possPos.x) {
                    mapPos--;
                    //otherwise pacman wants to move left
                } else if (curPos.x < possPos.x) {
                    mapPos++;
                }
                //if 'x' wasnt return than it has to be the y that is different
                //in this case pacman wants to move up or down
            } else {
                //if up then pacman needs to shift the length of a row in the 2-dim array
                if (curPos.y > possPos.y) {
                    mapPos -= currentMap[0].length;
                    //otherwise he needs to shift back the same length as he is going down
                } else {
                    mapPos += currentMap[0].length;
                }
            }
            //at this point, the position that pacman wants to move in is known in the array
            //so that position is returned
            return mapPos;
        }

        //simple update score function
        //takes in a value and adds it to the score
        function updateScore(i) {
            score += i;
            //score is checked against the amount of food left, if food amount is empty, then the map will be refilled by calling restartGame
            if (currGridScrVal <= 0) {
                canvas.width = canvas.width;
                pac.stunned = true;
                setTimeout(function () {
                    restartGame(objectStrtPos[0], objectStrtPos[1], objectStrtPos[2], objectStrtPos[3], mapArray, 2)
                }, 300);
            }
        }

        //simply changes the type of the block
        //takes in the position of the array and the new value on that position's type
        function changeMapType(pos, newT) {
            boundYSortArr[pos].type = newT;
        }

        //character collisions are checked here
        //as each character moves, their position in the grid is recorded
        //this allows me to simply check each characters current grid number against 
        //each other for accurate collision detection
        function chkCharacterCollisions(char1, char2) {
            if (!char2.deadMode) {
                if (char1.currPos == char2.currPos) {
                    if (char2.scaredMode == true && char1.type == "pac") {
                        canvas.width = canvas.width;
                        updateScore(10);
                        char2.deadMode = true;
                        char2.inGame = false;
                        return false;
                    }
                    return true;
                }
            }
            return false;
        }

        //chkMapNoType takes in the current position, the value in the array of the possible move
        function chkMapNoType(i, curPos, en) {
            if (curPos.name != "pac") {
                if (boundYSortArr[i].type == 16) {
                    if (en.inGame == false) {
                        return true;
                    } else {
                        return false;
                    }
                }

                //this needs a check as when in certain parts of the map these calculations will link to a grid square that dosnt exist
                //check if the possible route leads down to the portal corridor
                if ((boundYSortArr[(i - portalChannel)] != undefined && boundYSortArr[i + portalChannel] != undefined)) {
                    if (boundYSortArr[i + portalChannel].type == 10 || boundYSortArr[i - portalChannel].type == 10) {
                        return false;
                    }
                }


            }
            //checks are made to see if the possible move is a barrier  
            //i.e it's not a food or eaten food

            if ((boundYSortArr[i].type != 0) && (boundYSortArr[i].type != 3) && (boundYSortArr[i].type != 10) && (boundYSortArr[i].type != 13)) {

                //if this is entered, then the move is invalid immediately
                //this is a barrier       

                //a boolean is returned here stating that the position is invalid
                return false;
                //if the position is a food place it is valid for all characters to move to
            } else {
                //if pacman is the current character
                //the food will need to be eaten
                //the food state will need to change to eaten
                //and the score will need to be updated
                if (curPos.name == "pac") {
                    if (boundYSortArr[i].type == 0) {
                        currGridScrVal--;
                        boundYSortArr[i].type = 3;
                        changeMapType(i, 3);
                        updateScore(1);
                    } else if (boundYSortArr[i].type == 13) {
                        currGridScrVal--;
                        boundYSortArr[i].type = 3;
                        changeMapType(i, 3);
                        angry.updateScaredMode(true);
                        pinky.updateScaredMode(true);
                        updateScore(5);
                    }

                    //a check here tries to determine if the block is possibly a portal
                    //if it is then code needs to address that
                    if (boundYSortArr[i].type == 10) {
                        angry.recalcDirec = true;
                        pinky.recalcDirec = true;
                        //at this point, it is known that it is a portal
                        //we now need to see if it is a portal on the left or the right
                        //if on the left, we need to jump pacman to the far right hand side
                        if (boundYSortArr[i].x <= 30) {
                            pac.position.x = boundYSortArr[(i + currentMap[0].length) - 1].x;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i + currentMap[1].length - 2].type == 0) {
                                changeMapType(i + currentMap[1].length - 2, 3);
                                //score is updated also
                                updateScore(1);
                            }
                            //if the portal is not on the left then it is on the right
                            //the pacman's position will need to be changed
                        } else {
                            pac.position.x = 30;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i - currentMap[1].length + 3].type == 0) {
                                changeMapType(i - currentMap[1].length + 3, 3);
                                updateScore(1);
                            }
                        }
                    }
                }
            }

            //a boolean is returned here indicating that the position is valid
            return true;

        }

        //posDiff takes in two position objects
        //it will check if the x or the y positions are different
        function posDiff(curPos, possPos) {
            //x is different
            if (curPos.x != possPos.x) {
                return 'x';
            }
            //y is different
            else {
                return 'y';
            }
        }

        /*
            The main way the AI works is that it calculates the distance of the line between 
            the ghost's possible moves and some point on the map. I check the validity of a move up, down,
            left and right, and then calculate the distance between only the valid moves and the point on the map.
            
            The move is also not calculated every move, thee ghost only recalculates when theres an opening on the map.
            
            The ghost can also not go back on itself, unless it is scared or scattering.
            
            The red ghost moves towards pacman's actual location, while the pink ghost
            moves towards the co-ordinate 4 moves ahead of pacman. 
        */
        function redGhostUpdate(en) {
            //enemyDistances returns a list of numbers, numList is needed to store this list
            var numList;
            //mathDoer will grab either the highest or lowest distance value (game state dependent) from the numList
            var mathDoer;
            //collision is checked between the ghost and the user before the ghost moves, and also after the ghost moves
            if (chkCharacterCollisions(pac, en)) {
                //if there is a collision then a life should be taken, and the death animation should be played
                pac.reset();
            }

            //provided the ghost is in game (actively hunting pacman) it can move
            if (en.inGame) {
                enNormalMode(en);

                //if red has been told in the last run through that it needs to recalculate it's move, then it will do so here
                if (en.recalcDirec) {
                    //enemyDistances is called, it takes in the ghost's position and also a target position, it will then return a list of line distances
                    numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);

                    //if the AI is in scare or scattermode, it needs to move as far away from the target as possible
                    //in this case I simply calculate the max distance from the target from the list of numbers
                    if (en.scaredMode || en.scatterMode) {
                        mathDoer = Math.max.apply(null, numList);
                        //otherwise the ghost wants to move as closly as it can to it's target
                        //and so it then just needs to calculate the minimun distance instead
                    } else {
                        mathDoer = Math.min.apply(null, numList);
                    }

                    //calcEnMove will compare the distances with the min or max value
                    //as math.min/max does not return a position in the array, calcEnMove finds out which direction was chosen
                    //and then it will move in that direction
                    calcEnMove(numList[0], numList[1], numList[2], numList[3], mathDoer, en);
                }
                //if the ghost is in deadmode, or simply not inGame it needs to move independently of everything else in game
                //movToSpecLoc is called and the position it must move to is passed down
                //movToSpecLoc just gives the ghost a different target to the normal pacman
                //if its dead it needs to return to the cage to spawn back
                //and if it's not inGame, then it needs to initially move outside the cage
                //objectStrtPos contains the co-ordinates of both of these locations
            } else if (en.deadMode) {
                movToSpecLoc(en, numList, mathDoer, objectStrtPos[1]);
            } else if (score >= 5) {
                movToSpecLoc(en, numList, mathDoer, objectStrtPos[3]);
            }

        }

        //this function is the AI of the pink ghost
        //the breakdown of how the ghosts work is shown above the redGhostUpdate
        function pinkGhostUpdate(en) {
            var numList = [];
            var mathDoer;
            //collision detection is checked between pacman and the current enemy
            if (chkCharacterCollisions(pac, en)) {
                pac.reset();
            }
            //this section deals with the ghost hunting down pacman
            //inGame handles this and is turned on when the ghost leaves the cage
            if (en.inGame) {
                //the ghost can be inGame and also dead
                //this ensures the correct movement is used
                //i.e that it is running away from the target rather than hunting it
                if (en.deadMode) {
                    movToSpecLoc(en, numList, mathDoer, objectStrtPos[0]);
                    //this part will be for hunting pacman solely
                } else {
                    //enNormalMode checks wall collisions and then moves the ghost
                    //if valid move
                    enNormalMode(en);
                    //collision detection between the two ghosts
                    if (chkCharacterCollisions(angry, en)) {
                        //if the ghosts collide, a special provision is awarded, telling it to 
                        en.recalcDirec = true;
                    }
                    //if recalcDirec is true, the ghost needs to recalculate it's movement
                    if (en.recalcDirec == true) {
                        //pink ghost always tries to move in front of pacman
                        //to do this, numAhead is equal to 4 grid squares ahead of the ghost
                        //this will be added to the target position
                        //based on which direction the ghost is looking
                        var numAhead = 80;
                        //this part will send the co-ordinates of the enemy and of the variable set position in front of pacman
                        //unless pacman is to close to the end of the map, in that case, pacman's current position is passed instead
                        if (pac.speed.x > 0) {
                            //this if statement checks if the position the ghost will be targeting is actually on the grid or not
                            if (pac.position.x + numAhead < 590) {
                                //numList gathers the number list returned by enemyDistances
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x + numAhead, pac.position.y, en);
                            } else {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                            }
                        } else if (pac.speed.x < 0) {
                            if (pac.position.x - numAhead > 10) {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x - numAhead, pac.position.y, en);
                            } else {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                            }
                        } else if (pac.speed.y > 0) {
                            if (pac.position.y + numAhead < 630) {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y + numAhead, en);
                            } else {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                            }
                        } else {
                            if (pac.position.y - numAhead > 10) {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y - numAhead, en);
                            } else {
                                numList = enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
                            }
                        }
                        //recalculating dosn't need to be done every turn
                        //its both more efficient and also shows better behaviour to only recalculate under certain circumstances
                        en.recalcDirec = false;

                        //if the ghost is in scared mode or scattering, then it needs to move away from the target
                        //I do this by getting the max number from the list of line distances
                        if (en.scaredMode || en.scatterMode == true) {
                            mathDoer = Math.max.apply(null, numList);
                            //otherwise i just choose the shortest distance
                        } else {
                            mathDoer = Math.min.apply(null, numList);
                        }

                        //calcEnMove will compare the distances with the min value
                        //it will then move in that direction
                        calcEnMove(numList[0], numList[1], numList[2], numList[3], mathDoer, en);
                    }
                }
                //this code works for activating the ghost
                //when the user gets above 50 points
                //the pink ghost becomes active, it moves toward co-ordinates just outside the cage
                //then when it hits that point, it begins to use the above code that targets pacman
            } else if (score >= 50) {
                movToSpecLoc(en, numList, mathDoer, objectStrtPos[3]);
            }

        }

        
        //this function takes in a co-ordinate on the grid 
        //it then uses similar code to that used when targeting pacman
        //it uses that code to move toward a target grid position
        function movToSpecLoc(en, numList, mathDoer, position) {
            //if this code is called, then the ghost must be active
            en.isActive = true;
            //the ghost is moved in the current direction
            enNormalMode(en);
            //the distances list is returned, and the shortest distance to the target is chosen
            numList = enemyDistances(en.position.x, en.position.y, position.x, position.y, en);
            mathDoer = Math.min.apply(null, numList);
            //using the smallest number, calcEnMove checks the min number against the list, and moves in
            //whichever direction the minimum value represents
            calcEnMove(numList[0], numList[1], numList[2], numList[3], mathDoer, en);
            //if the ghost moves to the target, it needs to change to a new target
            if (en.position.x == position.x && en.position.y == position.y) {
                //if the ghost is alive, then it was just starting out, therefore, inGame is set to true
                //this will make the ghost now target pacman
                if (!en.deadMode) {
                    en.inGame = true;
                    //otherwise it is dead and has just returned to the cage
                    //it now needs to run through this function again until it is inGame
                } else{
                    en.deadMode = false;
                    en.inGame = false;
                }
            }
        }

        //this function checks the surrounding area of the ghost
        //if a the ghost has moved to the vicinity of a new opening
        //it returns true
        //it does this by checking the surrounding grid for moveable blocks
        //i.e if the block is a food block (0) an eaten food block (3) or a superfood block (13)
        function chkPossNewMoveAi(en) {
            if (en.speed.x > 0 || en.speed.x < 0) {
                if (boundYSortArr[en.currPos + currentMap[1].length].type == 3 || boundYSortArr[en.currPos + currentMap[1].length].type == 0 || boundYSortArr[en.currPos + currentMap[1].length].type == 13 || boundYSortArr[en.currPos - currentMap[1].length].type == 3 || boundYSortArr[en.currPos - currentMap[1].length].type == 0 || boundYSortArr[en.currPos - currentMap[1].length].type == 13) {
                    return true;
                }
            } else if (en.speed.y > 0 || en.speed.y < 0) {
                if (boundYSortArr[en.currPos + 1].type == 3 || boundYSortArr[en.currPos + 1].type == 0 || boundYSortArr[en.currPos + 1].type == 13 ||
                    boundYSortArr[en.currPos - 1].type == 3 || boundYSortArr[en.currPos - 1].type == 0 || boundYSortArr[en.currPos - 1].type == 13) {
                    return true;
                }
            }
            return false;
        }

        //this function moves the ghost towards the current trajectory
        //it checks for possible wall collisions 
        //if the intended move is valid, it moves to that grid square
        //otherwise it will recalculate the trajectory
        function enNormalMode(en) {
            var possMove;
            var pos, pos1;

            if (en.speed.x != 0) {
                //two objects are made, one with the current position, and one with the position, the ghost wants to move to
                possMove = en.position.x + en.speed.x;
                pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                pos1 = {
                    y: en.position.y,
                    x: possMove
                };
            } else if (en.speed.y != 0) {
                //same as above
                possMove = en.position.y + en.speed.y;
                pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                pos1 = {
                    y: possMove,
                    x: en.position.x
                };
            }

            
            en.enemyTurnCount++;
            var mapPos = getMapPos(pos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to
            mapPos = setPossDifference(pos, pos1, mapPos);
            var bool = chkMapNoType(mapPos, pos, en);
            en.currPos = mapPos;
            if (chkPossNewMoveAi(en) || en.scaredMode || en.scatterMode || chkCharacterCollisions(angry, pinky)) {
                //every 5th turn, or if the ghost is at a barrier or if the user changes directions
                //the ghost needs to recalculate its direction
                en.recalcDirec = true;
            }
            en.updateGhost(bool);
            if (chkCharacterCollisions(pac, en)) {
                pac.reset();
            }
        }

        //draws the enemy in it's current position
        function enemyDraw(en) {
            ctx.beginPath();
            //the sprites may need to change if its in normal mode
            //updateEyes checks the ghosts current trajectory, and adjusts the sprites accordingly
            if (!en.scaredMode) {
                en.updateEyes();
            }
            ctx.drawImage(en.img, en.imgXPos, en.imgYPos, en.imgW, en.imgH, en.position.x - 20, en.position.y - 20, en.sprW, en.sprH);
            ctx.closePath();
        }

        //this function calculates which direction is faster than the others for the AI to reach pacman
        function enemyDistances(eX, eY, usrX, usrY, en) {
            //initializing the directions to infinity or 0 depending on whether scattermode is turned on
            //this will ensure that if they are not valid options
            //and so they will not be counted
            if ((en.scatterMode == false && en.scaredMode == false) || (en.deadMode == true && en.isActive == true)) {
                var numList = [Infinity, Infinity, Infinity, Infinity],
                    mathDoer = 0;
            } else {
                var numList = [0, 0, 0, 0],
                    mathDoer = Infinity;
            }
            //creating a currPos object that stores the current position of the ghost
            //it also stores the fact that it is an enemy

            var enCurrPos = {
                y: eY,
                x: eX
            };

            var positions = [{
                    y: eY - 20,
                    x: eX,
                    spdX: 0,
                    spdY: -20
            },
                {
                    y: eY + 20,
                    x: eX,
                    spdX: 0,
                    spdY: 20
            },
                {
                    y: eY,
                    x: eX - 20,
                    spdX: -20,
                    spdY: 0
            },
                {
                    y: eY,
                    x: eX + 20,
                    spdX: 20,
                    spdY: 0
            }];


            //here the possible positions are checked
            //using the distance of a line formula
            //the direction with the shortest distance will be chosen

            var mapPos = getMapPos(enCurrPos);
            //setPossDifference alters mapPos so that it represents the
            //coOrdinates of the position to be moved to


            //mapHolder stores the mapPos in it's current form, mapPos will be altered and
            //and the original value of mapPos is needed to finish the calculations
            var mapHolder = mapPos;

            for (var counter = 0; counter < positions.length; ++counter) {
                mapPos = setPossDifference(enCurrPos, positions[counter], mapPos);
                if (chkMapNoType(mapPos, enCurrPos, en)) {
                    if ((en.speed.y != -positions[counter].spdY && en.speed.y != 0) || (en.speed.x != -positions[counter].spdX && en.speed.x != 0)) {
                        numList[counter] = dist(positions[counter].x, positions[counter].y + 20, usrX, usrY);
                    }
                }
                mapPos = mapHolder;
            }
            return (numList);
        }

        //basic distance of a line formula
        function dist(enX, enY, usrX, usrY) {
            var b1 = enX - usrX;
            b1 = Math.pow(b1, 2);
            var b2 = enY - usrY;
            b2 = Math.pow(b2, 2);
            return Math.sqrt(b1 + b2);
        }

        //checks which distance is min
        //whichever it is then it moves in that direction
        function calcEnMove(u, d, l, r, min, en) {
            if (u == min) {
                en.speed.x = 0;
                en.speed.y = -20;
            } else if (d == min) {
                en.speed.x = 0;
                en.speed.y = 20;
            } else if (r == min) {
                en.speed.x = 20;
                en.speed.y = 0;
            } else {
                en.speed.x = -20;
                en.speed.y = 0;
            }
        }

        //this function takes in the 2-dim array
        //and converts it to an object 1 dim array, containing x, y positions for each square in the grid
        //it also will contain the type of square that it is
        function popAccBoundArr() {
            var x = 20,
                y = 10;
            for (var i = 0; i < currentMap.length; ++i) {
                var inner = currentMap[i];
                y += 20;
                x = 30;
                for (var j = 0; j < inner.length; ++j) {
                    var outer = inner[j];
                    if (outer == 0 || outer == 13) {
                        updateMaxScore();
                    }
                    sortBoundaries(outer, x, y, boundYSortArr);
                    x += 20;
                }
            }
        }
        
        //currGridScrVal is incremented when the array is setup
        //and it is only called when the setup finds a food or superfood item on the map
        //then it is decremented by one everytime the user eats food
        //when currGridScrVal has been decrememnted to 0, the map should be out of food
        //the grid will then be reset and the score maintained for another "level"
        function updateMaxScore() {
            currGridScrVal++;
        }

        //this function creates a new array element with the passed in object parameters
        function sortBoundaries(type, x, y, arr) { 
            arr.push({
                type, x, y
            });
        }

        //this function reads the object array of grid squares
        //it then draws an object in the correct grid based on it's type
        
        /*
            
            it works in a similar manner to a paint by numbers
            each number has a specific part of the grid that it draws
            this could be a corner barrier or a piece of food.
            it takes the boundYSortArr's x and y co-ordinates and paints said 
            grid piece to the screen
        
        */
        function drawItems() {
            pac.drawLives();
            for (var i = 0; i < boundYSortArr.length; ++i) {
                switch (boundYSortArr[i].type) {

                    //food
                case 0:
                    ctx.beginPath();
                    ctx.fillStyle = "rgb(255,169,164)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 2, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0;
                    ctx.fill();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.closePath();
                    break;

                    //circles
                        
                        /*
                            unused code from earlier version
                            will keep it in case needed on future maps
                            it was used as a design for space in the middle of barriers
                        */
                case 1:
                    /* ctx.beginPath();
                     ctx.strokeStyle = "rgb(24,202,230)";
                     ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 10, 0, 2 * Math.PI, false);
                     ctx.lineWidth = 2;
                     ctx.stroke();
                     ctx.closePath();*/
                    break;

                    // verticle side
                case 2:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //eaten food
                case 3:
                    break;

                    //top left corner
                case 4:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //top right corner
                case 5:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //horizontal line
                case 6:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //bottom left Corner
                case 7:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //bottom right corner    
                case 8:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //end of line
                case 9:
                    break;

                    //portals
                case 10:
                    break;
                        //short vertical line
                case 11:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 5);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //short vertical line
                case 12:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 5);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                        //superfood
                case 13:
                    ctx.beginPath();
                    ctx.fillStyle = "rgb(255,169,164)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 5, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0;
                    ctx.fill();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.closePath();
                    break;

                        //short horizontal line
                case 14:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 5, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].ya);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                        //short horizontal line
                case 15:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(32,32,224)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 5, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                        //enemy cage exit
                case 16:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,60,60)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                }

                ctx.strokeStyle = "rgb(0,0,0)";
            }
        }

        //Local storage code
    
        //highscore object that keeps a name and a score stored together 
        function highscore(name, score) {
            this.name = name;
            this.score = score;
        }

        //takes in a number and adds on base zeros to make it a 4 digit number
        function convertTo4Digits(int) {
            if (int < 100 && int > 9) {
                int = "00" + int;
            } else if (int < 9) {
                int = "000" + int;
            } else if (int < 999) {
                int = "0" + int;
            }
            return int;
        }

        //takes in a string and returns the string incase it is not 3 letters long, 
        //it adds on base letters to the score's name
        function convertTo3Letters(str) {
            if (str.length == 2) {
                str = str + "A";
            } else if (str.length == 1) {
                str = str + "AA";
            } else if (str.length == 0) {
                str = "ABC";
            }
            return str;
        }

        //newScore takes in the user's name from the prompt window
        //it creates a highscore object 
        function newScore() {
            var userName = window.prompt("Enter your 3 initials: ", "");
            userName = userName.substr(0, 3);
            if (userName.length < 3) {
                userName = convertTo3Letters(userName);
            }
            var convrtdScr = convertTo4Digits(score);
            return new highscore(userName, convrtdScr);
        }

        //setupLS controls the entire highscores page
        function setupLS() {

            //it checks if the browser supports localStorage
            //if it does then we can work with highscores
            if (typeof (Storage) !== "undefined") {
                //highscores array is set to an empty array
                highscores = [];
                //it checks the first score, which will save it's value under the key of 0
                //if the value is null, then all the scores are reset and initiliased 
                if (localStorage.getItem(0) == null) {
                    //initiliising the highscores
                    initLS();
                } else {
                    //if the key 0 has a value, then scores will be grabbed from local storage
                    getLSItems();
                }
                //key 0 is the lowest score saved in the list, if the current score is higher than this score
                //the old lowest score can be removed 
                if (score > highscores[0].score) {
                    localStorage.removeItem(0);
                    //with a place made in the highscores
                    //a new highscore objet will need to be created
                    var nHS = newScore();
                    //the new object is saved in local storage and also in the highscores array
                    localStorage.setItem("0", nHS.name + "" + nHS.score);
                    highscores[0] = nHS;
                }
                //bubblesort is called on the highscores array
                //it sorts the highscores in order of their highscore-y-ness
                bubbleSort(highscores);
                //the sorted array replaces the local storage values
                saveScores();
                //finally the scores screen is displayed
                displayScores();

                //if the browser dosnt support highscores, then an alert will pop up telling the user they need to update their browser
            } else {
                // Sorry! No Web Storage support..
                alert("Update Browser!");
            }
        }

        //savescores runs through the array of highscores and saves them all in localstorage
        //the array should be presorted upon entering this function
        function saveScores() {
            for (var i = 0; i <= 10; ++i) {
                localStorage.setItem(i.toString(), highscores[i].name + "" + highscores[i].score);
            }
        }

        //if the localstorage is empty
        //10 initial highscores are created
        //these will have small simple values
        function initLS() {
            for (var scoreCount = 0; scoreCount <= 10; ++scoreCount) {
                //a very basic initial value is set with the name abc and the current value of scoreCount
                //set to 4 integers
                var nameScore = "ABC000" + scoreCount;
                //the long string of letters tied with scores are added to local storage at 
                //the location of whatever scoreCount currently is
                localStorage.setItem(JSON.stringify(scoreCount), nameScore);
                //the long string is parsed to a highscore object and then pushed to the highscores array
                var tmpScore = parseScrNme(nameScore)
                highscores.push(tmpScore);
            }

        }
        
        //this function simply loops through the localstorage
        //it grabs the long string value of the key
        //parses it to a highscore object and stores it in the highscores array
        function getLSItems() {
            for (var scoreCount = 0; scoreCount <= 10; ++scoreCount) {
                var nameScore = localStorage.getItem(JSON.stringify(scoreCount));
                var tmpScore = parseScrNme(nameScore)
                highscores.push(tmpScore);
            }
        }

        //display scores displays the entire highscore screen
        function displayScores() {

            //a temporary use enemy object is created 
            var menuPinky = new enemy({
                x: 800,
                y: 570
            }, {
                x: -20,
                y: 0
            }, "enemy", 80);

            //count loops down while counterCount loops up in the setInterval loop below
            //together they allow for the scores to be accessed in ascending order, while being written in descending order
            var count = 10;
            var counterCount = 0;
            
            //ctx draws the headers, rank, name and score, and below where the list of scores will be located
            //it writes click to replay
            //the mouse listener will listen to any canvas clicks and reset the game accordingly
            canvas.height = canvas.height;
            ctx.fillStyle = "rgb(0,0,0,)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.fillStyle = 'yellow';
            ctx.textAlign = 'center';
            ctx.font = "40px Arial";
            ctx.fillText("Highscores", 475, 65);
            ctx.fillText("Rank          Name              Score", 500, 165);
            ctx.fillText("Click to replay...", 500, 575);
            ctx.closePath();
            //strtGameCntrl is set to true, this enables the mouse listener which will restart the game on click
            strtGameCntrl = true;

            //this part deals with all the animation required on screen
            //cx holds the enemy's current horizontal speed
            var cX;
            cX = menuPinky.speed.x;
            //setInterval loops around the following block of code until strtGameCntrl is set to false
            //this is achieved by a click on the screen
            //so when the user clicks the canvas, the loop exits, stopping the animation
            var intrvl = setInterval(function () {
                if (strtGameCntrl == false) {
                    clearInterval(intrvl);
                } else {
                    //depending on the count value
                    //ctx will write the next score to be written to the canvas
                    //due to the interval loop, the highscores are written one by one, which I found to be 
                    //a nice way to display them
                    if (count > 0) {
                        ctx.beginPath();
                        ctx.fillStyle = 'pink';
                        ctx.textAlign = 'center';
                        ctx.font = "20px Arial";
                        ctx.fillText((counterCount + 1), 250, 220 + (counterCount * 30));
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.fillStyle = 'pink';
                        ctx.fillText(highscores[count].name, 475, 220 + (counterCount * 30));
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.fillStyle = 'pink';
                        ctx.fillText(highscores[count].score, 725, 220 + (counterCount * 30));
                        ctx.closePath();
                        count--;
                        counterCount++;
                    }
                    //menuEnMv moves the ghost across the screen for the animation effect
                    cX = menuEnMv(cX, menuPinky);
                    //enemyDraw is called to draw the enemy to the screen
                    enemyDraw(menuPinky);
                }
            }, 150);
        }

        //using a bubblesort to sort the highscores as it is easy to implement
        //and also because it will only be used on a small data set, speed and efficiency 
        //shouldnt be effected too much
        function bubbleSort(arr) {
            var swapped;
            do {
                swapped = false;
                for (var i = 0; i < arr.length - 1; ++i) {
                    if (arr[i].score > arr[i + 1].score) {
                        var temp = arr[i];
                        arr[i] = arr[i + 1];
                        arr[i + 1] = temp;
                        swapped = true;
                    }
                }
            } while (swapped);
        }

        //this function takes in the long form names that are written to the local storage as there is only room for one value per key
        //and converts them into highscore objects
        function parseScrNme(name) {
            return (new highscore(name.substring(0, 3), name.substring(3, 7)));
        }

        //menuEnMv controls the movement of menu enemies
        function menuEnMv(cX, menuPinky) {
            ctx.fillStyle = 'black';
            ctx.fillRect(menuPinky.position.x - 20, menuPinky.position.y - 20, 40, 40);

            //the location of click to continue is coded into the if statements, and allow the ghost to "avoid" the words
            if ((menuPinky.position.x == 660 && (menuPinky.position.y - 20 == 550 || menuPinky.position.y - 20 == 570 || menuPinky.position.y - 20 == 590))) {
                if (cX < 0) {
                    if (menuPinky.position.y - 20 != 590) {
                        menuPinky.speed.y = 20;
                        menuPinky.speed.x = 0;
                    } else {
                        menuPinky.speed.y = 0;
                        menuPinky.speed.x = -20;
                    }
                } else {
                    if (menuPinky.position.y - 20 != 550) {
                        menuPinky.speed.y = -20;
                        menuPinky.speed.x = 0;
                    } else {
                        menuPinky.speed.y = 0;
                        menuPinky.speed.x = 20;
                    }
                }
                //more recalculating of the ghosts location relative to the words click to continue
            } else if (menuPinky.position.x - 20 == 320 && (menuPinky.position.y - 20 == 590 || menuPinky.position.y - 20 == 570 || menuPinky.position.y - 20 == 550)) {
                if (cX < 0) {
                    if (menuPinky.position.y - 20 != 550) {
                        menuPinky.speed.y = -20;
                        menuPinky.speed.x = 0;
                    } else {
                        menuPinky.speed.y = 0;
                        menuPinky.speed.x = -20;
                    }
                } else {
                    if (menuPinky.position.y - 20 != 590) {
                        menuPinky.speed.y = 20;
                        menuPinky.speed.x = 0;
                    } else {
                        menuPinky.speed.y = 0;
                        menuPinky.speed.x = 20;
                    }
                }
                //if the ghost hits the edge of either side of the canvas, it moves in the opposite direction
            } else if (menuPinky.position.x <= 110 || menuPinky.position.x > canvas.width - 110) {
                cX = -cX;
                menuPinky.speed.x = -menuPinky.speed.x;
                //otherwise its speed is set here
            } else {
                if (cX < 0) {
                    menuPinky.speed.y = 0;
                    menuPinky.speed.x = -20;
                } else {
                    menuPinky.speed.y = 0;
                    menuPinky.speed.x = 20;
                }
            }
            //the ghost's position is updated here
            menuPinky.position.y += menuPinky.speed.y;
            menuPinky.position.x += menuPinky.speed.x;
            return cX;
        }
    </script>

</body>

</html>