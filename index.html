<!DOCTYPE html>

<html>

<head>
    <meta charset="UTF-8">
    <title>Pacman</title>
    </style>

</head>

<body>

    <canvas id="canvasOne"></canvas>

    <script type="text/javascript">
        
        //2 canvas variables used in drawing the canvas, theses are integral to the program
        var ctx;
        var canvas;
        
        //create the map array that will be processed to draw the map on screen
        var mapArray = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
         [10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10],
          [2, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 2],
          [2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],
          [2, 0, 7, 6, 6, 6, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 0, 4, 6, 6, 5, 0, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 6, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2],
          [2, 6, 5, 0, 4, 6, 6, 8, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 4, 8, 1, 1, 7, 5, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 7, 6, 6, 5, 0, 4, 6, 2],
          [2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 0, 2, 1, 1, 1, 1, 1, 2, 0, 2, 0, 7, 6, 6, 6, 6, 8, 0, 2, 0, 2, 1, 1, 1, 1, 1, 2, 0, 2, 0, 0, 0, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 6, 6, 6, 6, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [2, 1, 2, 0, 4, 6, 6, 6, 5, 0, 9, 6, 6, 6, 6, 5, 0, 9, 6, 8, 0, 2, 3, 3, 3, 3, 2, 0, 7, 6, 9, 0, 4, 6, 6, 6, 6, 9, 0, 4, 6, 6, 6, 5, 0, 2, 1, 2],
          [2, 6, 8, 0, 2, 1, 1, 1, 2, 0, 2, 1, 1, 1, 1, 2, 0, 2, 0, 0, 0, 2, 3, 3, 3, 3, 2, 3, 0, 0, 2, 0, 2, 1, 1, 1, 1, 2, 0, 2, 1, 1, 1, 2, 0, 7, 6, 2],
         [10, 0, 0, 0, 2, 1, 1, 1, 2, 0, 9, 6, 6, 6, 6, 8, 0, 2, 0, 4, 6, 3, 3, 3, 3, 3, 7, 6, 5, 0, 2, 0, 7, 6, 6, 6, 6, 9, 0, 2, 1, 1, 1, 2, 0, 0, 0, 10],
          [2, 6, 5, 0, 2, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 2, 0, 4, 6, 2],
          [2, 1, 2, 0, 2, 1, 1, 1, 2, 0, 4, 6, 5, 0, 4, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 5, 0, 4, 6, 5, 0, 2, 1, 1, 1, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 7, 6, 6, 6, 8, 0, 2, 1, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 2, 0, 7, 6, 6, 6, 8, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 2, 0, 4, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 5, 0, 2, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 0, 9, 6, 9, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 9, 6, 9, 0, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 9, 0, 9, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 9, 0, 9, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8]
      ];

        //boundYSortArr will hold the processed objects that are formed from the 2-dim map array
        var boundYSortArr = [];

        //last press holds the last key pressed by the user, it needs to be global to keep it in scope
        var lastPress;
        //"not pressed" controls whether or not to use the last press or the current press
        var notPressed = false;
        //global score variable, is incremented when a user eats food
        var score = 0;

        /*
        
        
        PLACEHOLDER, FIND ACTUAL USE OF OPCLBOOL
        */
        var opnClsBool = 0;

        
        //this is an object definition that takes in 2 values and stores them in an object
        //the values passed will be the x/y co-ordinates of another object
        function coOrds(x, y) {
            this.x = x;
            this.y = y;
        }

        
        //this is a character definition that stores position, speed and the type of character
        //position and speed are co-ords that store an x and y value
        //type should be just a string
        //currPos will be updated whenever the the algorithm finds the user's position
        function character(position, speed, type) {
            this.position = new coOrds(position.x, position.y);
            this.speed = new coOrds(speed.x, speed.y);
            this.type = type;
            this.currPos = 0;
        }

        
        //creating 3 character objects
        //the first 2 are enemies while the third is our hero pac
        var en1 = new character({
            x: 530,
            y: 250
        }, {
            x: 20,
            y: 0
        }, "enemy");
        var en2 = new character({
            x: 470,
            y: 250
        }, {
            x: 20,
            y: 0
        }, "enemy");
        var pac = new character({
            x: 270,
            y: 130
        }, {
            x: 20,
            y: 0
        }, "pac");

        init();
        
        //the init function initialises the canvas as well as calling the functions to popAccBoundArr and the draw function
        function init()
        {
            //init canvas
            canvas = document.getElementById("canvasOne");
            canvas.height = 550;
            canvas.width = 1000;
            ctx = canvas.getContext("2d");
            popAccBoundArr();
            draw();
        }

        //the draw function draws the canvas
        function draw() {
            //resetting the canvas width clears the canvas for the next animation frame
            canvas.width = canvas.width;
            
            //this draws the canvas rectangle
            //and fills it with a dark blue colour
            ctx.beginPath()
            ctx.lineWidth = 2;
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(7,2,42)";
            ctx.fill();
            ctx.closePath();
            
            //score is drawn on the screen here
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.font = "30px Arial";
            ctx.fillText("Score: " + score, 30, 520);
            //ctx.closePath();
            //window.requestAnimationFrame(chkCollisions);

            //keypress events are handled here
            //the if statement checks the state of the notpressed boolean var
            //essentially it takes the current key pressed or the last key pressed
            //and passes that number to a move function that handles either presses
            if (notPressed == false) {
                document.addEventListener('keydown', function (event) {
                    move(event.keyCode);
                });
            } else if (notPressed == true) {
                move(lastPress);
            }
            
            //call 2 functions
            update();
            pcDirctnSwtch();
        }

        
        //this fucntion takes in a number "press"
        //it checks for collisions and then alters the user speeds accordingly
        function move(press) {
            
            /*
            
            
            
            REMOVE SIDE FROM THIS, IT'S NO GOOD
            
            
            */
            side ='';// chkCollisions();

            //key press handled here
            //checks collisions to the direction of pacman, 
            //if it's a valid place to move, speeds are altered
            //if it would cause a collision, the key will be saved for later and processed at the next available opportunity 
            //each press is effectively the same, only changing the needed speeds and checking the correct collisions
            
            //left key press
            if (press == 37) {
                if (side.x != 'r' && (boundYSortArr[pac.currPos - 1].type == 3 || boundYSortArr[pac.currPos - 1].type == 0)) {
                    pac.speed.x = -20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //right key press
            else if (press == 39) {
                if (side.x != 'l' && (boundYSortArr[pac.currPos + 1].type == 3 || boundYSortArr[pac.currPos + 1].type == 0)) {
                    pac.speed.x = 20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //down key press
            else if (press == 40) {
                if (side.y != 'd' && (boundYSortArr[pac.currPos + 48].type == 3 || boundYSortArr[pac.currPos + 48].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = 20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //up key press
            else if (press == 38) {
                if (side.y != 'u' && (boundYSortArr[pac.currPos - 48].type == 3 || boundYSortArr[pac.currPos - 48].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = -20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
        }

        //this function checks the speed of pacman
        //based on which speed is not 0, pacman will be drawn in a different direction
        //it calls pacDraw which takes in variables needed to draw the 3/4 circle that is pacman
        function pcDirctnSwtch() {
            //for pacman to face right
            if (pac.speed.x > 0) {
                pacDraw(1.8, 0.2);
                //for pacman to face to the left
            } else if (pac.speed.x < 0) {
                pacDraw(0.8, 1.2);
                //for pacman to face down
            } else if (pac.speed.y > 0) {
                pacDraw(0.2, 0.8)
                //for pacman to face up
            } else if (pac.speed.y < 0) {
                pacDraw(1.2, 1.8);
            }
        }

        //this function is used to draw the main man
        //it takes in two variables that are multiplied by pi
        //essentially these variables control the direction pacman will face
        function pacDraw(pi1, pi2) {
            
            //this is a simple sound file that plays on a loop as pacman is drawn
            //it is taken straight from the original pacman game
            //I find it adds authenticity to my unauthorized clone of pacman
            var snd = new Audio("waka waka.mp3"); // buffers automatically when created
            snd.play();
            
            //draw all is called to draw the enemies and the map
            drawAll();

            //pacman is drawn
            ctx.beginPath();
            //pacman-yellow is set as the current fill style
            ctx.fillStyle = "rgb(255,238,0)";
            //opnClsBool controls the open close nature of pacmans mouth
            //when "on" it draws him open mouthed
            //when off it draws him closed mouth
            if (opnClsBool == 0) {
                //open mouth drawn
                ctx.arc(pac.position.x, pac.position.y, 15, pi1 * Math.PI, pi2 * Math.PI, true);
                ctx.lineTo(pac.position.x, pac.position.y);
                //sets the variable to 1 so that on next draw it will draw a full circle
                opnClsBool = 1;
            } else {
                //draw a full circle
                ctx.arc(pac.position.x, pac.position.y, 15, 2 * Math.PI, 0 * Math.PI, true);
                //set the variable to 0, effectively resetting pacman for the next draw to be open mouthed
                opnClsBool = 0;
            }
            
            //fills in the pacman object drawn to the canvas
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = "rgb(0,0,0)";
            /*
                REMOVE AT LATER DATE
            
            */
            //window.requestAnimationFrame(chkCollisions);
            
            //checks stae of opnClsBool
            //if only half way through the animation, redraw the pacman
            //or else redraw the canvas
            if (opnClsBool == 1) {
                setTimeout(function () {
                    pacDraw(pi1, pi2);
                }, 100)
            } else {
                setTimeout(draw, 300);
            }
        }
        
        //draw all simply calls draw functions to draw the rest of the objects
        function drawAll() {
            drawItems();
            enemyDraw(en1);
            enemyDraw(en2);
        }
        
        /*
        
            PROBLY WILL BE REMOVED
            NOT SURE ON IT'S USE ANY MORE
            NEEDS FURTHER TESTING
        */

        function chkCollisions() {
            var side = {
                x: '',
                y: ''
            };
            if (pac.position.x + 25 >= canvas.width - 15 || pac.position.x - 25 <= 0 + 15) {
                pac.speed.x = 0;
                if (pac.position.x > (canvas.width / 2)) {
                    side.x = 'r';
                } else {
                    side.x = 'l';
                }
            }
            if (pac.position.y + 25 >= canvas.height - 15 || pac.position.y - 25 <= 0 + 15) {
                pac.speed.y = 0;
                if (pac.position.y > (canvas.height / 2)) {
                    side.y = 'd';
                } else {
                    side.y = 'u';
                }
            }
            return side;
        }

        function update() {
            usrUpdate(pac);
            enUpdate(en1);
            enUpdate(en2);
        }

        function usrUpdate(pac) {
            var possMove;
            var bool;
            if (pac.speed.x != 0) {
                //chk the space to the left or right   
                possMove = pac.position.x + pac.speed.x;
                var pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                var pos1 = {
                    y: pac.position.y,
                    x: possMove
                };
                bool = chkVertMapColl(pos, pos1);
            } else if (pac.speed.y != 0) {
                //chk the space up or down   
                possMove = pac.position.y + pac.speed.y;
                var pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                var pos1 = {
                    y: possMove,
                    x: pac.position.x
                };
                bool = chkVertMapColl(pos, pos1);
            }
            if (bool == false) {
                pac.position.x += pac.speed.x;
                pac.position.y += pac.speed.y;
            }
            else{
                pac.position-=pac.speed.x;   
            }
        }

        function getMapPos(curPos, possPos) {
            for (i = 0; i < boundYSortArr.length; ++i) {
                if (curPos.y != boundYSortArr[i].y) {
                    i += mapArray[1].length - 1;
                } else if (curPos.x == boundYSortArr[i].x) {
                    //found currunt position
                    if (posDiff(curPos, possPos) == 'x') {
                        if (curPos.x > possPos.x) {
                            i--;
                        } else if (curPos.x < possPos.x) {
                            i++;
                        }
                    } else {
                        if (curPos.y > possPos.y) {
                            i -= mapArray[0].length;
                        } else {
                            i += mapArray[0].length;
                        }
                    }
                    return i;
                }
            }
        }

        function updateScore(i) {
            score += i;
        }

        function changeMapType(pos, newT) {
            boundYSortArr[pos].type = newT;
        }

        function chkMapNoType(i, curPos, possPos) {
            //chk type
            if ((boundYSortArr[i].type != 0) && (boundYSortArr[i].type != 3)) {
                
                //portal time!
                if (boundYSortArr[i].type == 10) {
                    if (boundYSortArr[i].x <= 30) {
                        pac.position.x = 950;

                        if (boundYSortArr[i + mapArray[1].length - 3].type == 0) {
                            changeMapType(i + mapArray[1].length - 2, 3);
                            updateScore(1);
                        }
                    } else {
                        pac.position.x = 50;

                        if (boundYSortArr[i - mapArray[1].length - 2].type == 0) {
                            changeMapType(i - mapArray[1].length - 2, 3);
                            updateScore(1);
                        }
                    }
                }
                
                if(curPos.name=="pac")
                {
                   /* pac.speed.y=0;
                    pac.position.x-=20;
                    pac.speed.x=0*/
                }
                return true;
            } else {
                if (curPos.name == "pac") {
                    if (boundYSortArr[i].type == 0) {
                        boundYSortArr[i].type = 3;
                        changeMapType(i, 3);
                        updateScore(1);
                    }
                }

                return false;
            }
        }

        function chkVertMapColl(curPos, possPos) {

            var i = getMapPos(curPos, possPos);

            if (curPos.name == "pac") {
                pac.currPos = i;
            }
            var bool = chkMapNoType(i, curPos, possPos);
            
            chkSpeed();
            return bool;
        }
        
        function chkSpeed()
        {
            if(pac.xSpeed==0&&pac.ySpeed==0)
            {
                pac.position.x--;
                pac.position.y--;
            }
           
        }

        function posDiff(curPos, possPos) {
            //x is different
            if (curPos.x != possPos.x) {
                return 'x';
            }
            //y is different
            else {
                return 'y';
            }
        }

        function enUpdate(en) {

            enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);
            var possMove;
            var bool;
            if (en.speed.x != 0) {
                //chk the space to the left or right   
                possMove = en.position.x + en.speed.x;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: en.position.y,
                    x: possMove
                };
                bool = chkVertMapColl(pos, pos1);
            } else if (en.speed.y != 0) {
                //chk the space up or down   
                possMove = en.position.y + en.speed.y;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: possMove,
                    x: en.position.x
                };
                bool = chkVertMapColl(pos, pos1);
            }
            if (bool == false) {
                en.position.x += en.speed.x;
                en.position.y += en.speed.y;
            }
        }

        function enemyDraw(en) {
            ctx.beginPath();
            if (en == en1) {
                ctx.fillStyle = "rgb(240,33,17)";
            } else {
                ctx.fillStyle = "rgb(0,0,17)";
            }
            ctx.arc(en.position.x, en.position.y, 15, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.closePath();
        }

        function enemyDistances(eX, eY, usrX, usrY, en) {
            var up = Infinity,
                left = Infinity,
                right = Infinity,
                down = Infinity,
                min = 0;
            var currPos = {
                y: en.position.y,
                x: en.position.x,
                name: en.type
            };
            var upPos = {
                y: eY - 10,
                x: eX
            };
            var downPos = {
                y: eY + 10,
                x: eX
            };
            var leftPos = {
                y: eY,
                x: eX - 10
            };
            var rightPos = {
                y: eY,
                x: eX + 10
            };

            if (!chkVertMapColl(currPos, upPos)) {
                up = dist(eX, eY - 10, usrX, usrY);
            }
            if (!chkVertMapColl(currPos, downPos)) {
                down = dist(eX, eY + 10, usrX, usrY);
            }
            if (!chkVertMapColl(currPos, rightPos)) {
                right = dist(eX + 10, eY, usrX, usrY);
            }
            if (!chkVertMapColl(currPos, leftPos)) {
                left = dist(eX - 10, eY, usrX, usrY);
            }

            min = Math.min(up, down, right, left);
            calcEnMove(up, down, right, left, min, en);
        }

        function dist(enX, enY, usrX, usrY) {
            var b1 = enX - usrX;
            b1 = Math.pow(b1, 2);
            var b2 = enY - usrY;
            b2 = Math.pow(b2, 2);
            return Math.sqrt(b1 + b2);
        }

        function calcEnMove(u, d, r, l, min, en) {
            if (u == min) {
                en.speed.x = 0;
                en.speed.y = -20;
            } else if (d == min) {
                en.speed.x = 0;
                en.speed.y = 20;
            } else if (r == min) {
                en.speed.x = 20;
                en.speed.y = 0;
            } else {
                en.speed.x = -20;
                en.speed.y = 0;
            }
        }

        function popAccBoundArr() {
            var x = 20,
                y = 10;
            for (var i = 0; i < mapArray.length; ++i) {
                var inner = mapArray[i];
                y += 20;
                x = 30;
                for (var j = 0; j < inner.length; ++j) {
                    var outer = inner[j];
                    sortBoundaries(outer, x, y, boundYSortArr);
                    x += 20;
                }
            }
        }


        function sortBoundaries(type, x, y, arr) {
            arr.push({
                type, x, y
            });
        }

        function drawItems() {
            for (var i = 0; i < boundYSortArr.length; ++i) {
                switch (boundYSortArr[i].type) {

                    //boundary
                case 0:
                    ctx.beginPath();
                    ctx.fillStyle = "rgb(9,245,0)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 3, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0;
                    ctx.fill();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.closePath();
                    break;

                case 1:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 10, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    // verticle side
                case 2:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //eaten food
                case 3:
                    break;

                    //top left corner
                case 4:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //top right corner
                case 5:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //horizontal line
                case 6:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //bottom left Corner
                case 7:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //bottom right corner    
                case 8:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //end of line
                case 9:
                    break;
                case 10:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                }

                ctx.strokeStyle = "rgb(0,0,0)";
            }
        }
    </script>

</body>

</html>