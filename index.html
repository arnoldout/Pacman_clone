<!DOCTYPE html>

<html>

<head>
    <meta charset="UTF-8">
    <title>Pacman</title>
    </style>

</head>

<body>

    <canvas id="canvasOne"></canvas>

    <script type="text/javascript">
        //2 canvas variables used in drawing the canvas, theses are integral to the program
        var ctx;
        var canvas;

        //this counts every turn taken by the enemy
        //will be helpful in allowing the ghosts better movement
        //will stop need to recalculate path every turn
        var enemyTurnCount = 0;

        var recalcDirec = true;
        
        var oldX = 0,
            oldY = 0;
        //create the map array that will be processed to draw the map on screen
        var mapArray = [
          [4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5],
          [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
          [2, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 2],
          [2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],
          [2, 0, 7, 6, 6, 6, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 0, 4, 6, 6, 5, 0, 0, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 6, 6, 6, 8, 0, 2],
          [2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2],
          [2, 6, 5, 0, 4, 6, 6, 8, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 4, 8, 1, 1, 7, 5, 0, 2, 0, 4, 6, 6, 6, 6, 6, 5, 0, 2, 0, 7, 6, 6, 5, 0, 4, 6, 2],
          [2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 0, 2, 1, 1, 1, 1, 1, 2, 0, 2, 0, 7, 6, 6, 6, 6, 8, 0, 2, 0, 2, 1, 1, 1, 1, 1, 2, 0, 2, 0, 0, 0, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 6, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 6, 6, 6, 6, 6, 8, 0, 7, 6, 6, 6, 6, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [2, 1, 2, 0, 4, 6, 6, 6, 5, 0, 9, 6, 6, 6, 6, 5, 0, 9, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 9, 0, 9, 0, 4, 6, 6, 6, 6, 9, 0, 4, 6, 6, 6, 5, 0, 2, 1, 2],
          [9, 6, 8, 0, 2, 1, 1, 1, 2, 0, 2, 1, 1, 1, 1, 2, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 2, 0, 2, 1, 1, 1, 1, 2, 0, 2, 1, 1, 1, 2, 0, 7, 6, 9],
         [10, 3, 0, 0, 2, 1, 1, 1, 2, 0, 9, 6, 6, 6, 6, 8, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 0, 2, 0, 7, 6, 6, 6, 6, 9, 0, 2, 1, 1, 1, 2, 0, 0, 3, 10],
          [9, 6, 5, 0, 2, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 2, 0, 4, 6, 9],
          [2, 1, 2, 0, 2, 1, 1, 1, 2, 0, 4, 6, 5, 0, 4, 6, 6, 8, 0, 3, 3, 3, 3, 3, 6, 6, 6, 6, 8, 0, 7, 6, 6, 5, 0, 4, 6, 5, 0, 2, 1, 1, 1, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 7, 6, 6, 6, 8, 0, 2, 1, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 2, 0, 7, 6, 6, 6, 8, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 2, 0, 4, 6, 5, 0, 4, 6, 6, 6, 6, 6, 6, 5, 0, 4, 6, 5, 0, 2, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 0, 9, 6, 9, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 9, 6, 9, 0, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 2, 1, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 9, 0, 9, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 7, 6, 8, 0, 9, 0, 7, 6, 8, 0, 9, 0, 9, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 2],
          [2, 1, 2, 0, 9, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 9, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 0, 9, 0, 2, 1, 2],
          [2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2],
          [7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8]
      ];

        //boundYSortArr will hold the processed objects that are formed from the 2-dim map array
        var boundYSortArr = [];

        //last press holds the last key pressed by the user, it needs to be global to keep it in scope
        var lastPress;
        //"not pressed" controls whether or not to use the last press or the current press
        var notPressed = false;
        //global score variable, is incremented when a user eats food
        var score = 0;

        //opnClsBool controls the motion of pacmans mouth movement
        //when 0 his mouth is open
        //when 1 his mouth is closed
        var opnClsBool = 0;


        //this is an object definition that takes in 2 values and stores them in an object
        //the values passed will be the x/y co-ordinates of another object
        function coOrds(x, y) {
            this.x = x;
            this.y = y;
        }


        //this is a character definition that stores position, speed and the type of character
        //position and speed are co-ords that store an x and y value
        //type should be just a string
        //currPos will be updated whenever the the algorithm finds the user's position
        function character(position, speed, type) {
            this.position = new coOrds(position.x, position.y);
            this.speed = new coOrds(speed.x, speed.y);
            this.type = type;
            this.currPos = 0;
        }


        //creating 3 character objects
        //the first 2 are enemies while the third is our hero pac
        var en1 = new character({
            x: 90,
            y: 250
        }, {
            x: 20,
            y: 0
        }, "enemy");
        var en2 = new character({
            x: 890,
            y: 50
        }, {
            x: 20,
            y: 0
        }, "enemy");
        var pac = new character({
            x: 890,
            y: 270
        }, {
            x: 20,
            y: 0
        }, "pac");

        init();

        //the init function initialises the canvas as well as calling the functions to popAccBoundArr and the draw function
        function init() {
            //init canvas
            canvas = document.getElementById("canvasOne");
            canvas.height = 550;
            canvas.width = 1000;
            ctx = canvas.getContext("2d");
            oldX = pac.speed.x;
            oldY = pac.speed.y;
            popAccBoundArr();
            draw();
        }

        //the draw function draws the canvas
        function draw() {
            //resetting the canvas width clears the canvas for the next animation frame
            canvas.width = canvas.width;

            //this draws the canvas rectangle
            //and fills it with a dark blue colour
            ctx.beginPath()
            ctx.lineWidth = 2;
            ctx.rect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "rgb(7,2,42)";
            ctx.fill();
            ctx.closePath();

            //score is drawn on the screen here
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.font = "30px Arial";
            ctx.fillText("Score: " + score, 30, 520);
            ctx.closePath();

            //keypress events are handled here
            //the if statement checks the state of the notpressed boolean var
            //essentially it takes the current key pressed or the last key pressed
            //and passes that number to a move function that handles either presses
            if (notPressed == false) {
                document.addEventListener('keydown', function (event) {
                    move(event.keyCode);
                });
            } else if (notPressed == true) {
                move(lastPress);
            }

            //call 2 functions
            update();
            pcDirctnSwtch();
        }


        //this fucntion takes in a number "press"
        //it checks for collisions and then alters the user speeds accordingly
        function move(press) {


            //key press handled here
            //checks collisions to the direction of pacman, 
            //if it's a valid place to move, speeds are altered
            //if it would cause a collision, the key will be saved for later and processed at the next available opportunity 
            //each press is effectively the same, only changing the needed speeds and checking the correct collisions

            //left key press
            if (press == 37 || press == 65) {
                if ((boundYSortArr[pac.currPos - 1].type == 3 || boundYSortArr[pac.currPos - 1].type == 0)) {
                    pac.speed.x = -20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //right key press
            else if (press == 39 || press == 68) {
                if ((boundYSortArr[pac.currPos + 1].type == 3 || boundYSortArr[pac.currPos + 1].type == 0)) {
                    pac.speed.x = 20;
                    pac.speed.y = 0;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //down key press
            else if (press == 40 || press == 83) {
                if ((boundYSortArr[pac.currPos + 48].type == 3 || boundYSortArr[pac.currPos + 48].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = 20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
            //up key press
            else if (press == 38 || press == 87) {
                if ((boundYSortArr[pac.currPos - 48].type == 3 || boundYSortArr[pac.currPos - 48].type == 0)) {
                    pac.speed.x = 0;
                    pac.speed.y = -20;
                    notPressed = false
                } else {
                    lastPress = press;
                    notPressed = true;
                }
            }
        }

        //this function checks the speed of pacman
        //based on which speed is not 0, pacman will be drawn in a different direction
        //it calls pacDraw which takes in variables needed to draw the 3/4 circle that is pacman
        function pcDirctnSwtch() {
            //for pacman to face right
            if (pac.speed.x > 0) {
                pacDraw(1.8, 0.2);
                //for pacman to face to the left
            } else if (pac.speed.x < 0) {
                pacDraw(0.8, 1.2);
                //for pacman to face down
            } else if (pac.speed.y > 0) {
                pacDraw(0.2, 0.8)
                    //for pacman to face up
            } else if (pac.speed.y < 0) {
                pacDraw(1.2, 1.8);
            }
        }

        //this function is used to draw the main man
        //it takes in two variables that are multiplied by pi
        //essentially these variables control the direction pacman will face
        function pacDraw(pi1, pi2) {

            //this is a simple sound file that plays on a loop as pacman is drawn
            //it is taken straight from the original pacman game
            //I find it adds authenticity to my unauthorized clone of pacman
            var snd = new Audio("waka waka.mp3"); // buffers automatically when created
            snd.play();

            //draw all is called to draw the enemies and the map
            drawAll();

            //pacman is drawn
            ctx.beginPath();
            //pacman-yellow is set as the current fill style
            ctx.fillStyle = "rgb(255,238,0)";
            //opnClsBool controls the open close nature of pacmans mouth
            //when "on" it draws him open mouthed
            //when off it draws him closed mouth
            if (opnClsBool == 0) {
                //open mouth drawn
                ctx.arc(pac.position.x, pac.position.y, 15, pi1 * Math.PI, pi2 * Math.PI, true);
                ctx.lineTo(pac.position.x, pac.position.y);
                //sets the variable to 1 so that on next draw it will draw a full circle
                opnClsBool = 1;
            } else {
                //draw a full circle
                ctx.arc(pac.position.x, pac.position.y, 15, 2 * Math.PI, 0 * Math.PI, true);
                //set the variable to 0, effectively resetting pacman for the next draw to be open mouthed
                opnClsBool = 0;
            }

            //fills in the pacman object drawn to the canvas
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = "rgb(0,0,0)";

            //checks stae of opnClsBool
            //if only half way through the animation, redraw the pacman
            //or else redraw the canvas
            if (opnClsBool == 1) {
                setTimeout(function () {
                    pacDraw(pi1, pi2);
                }, 100)
            } else {
                setTimeout(draw, 300);
            }
        }

        //draw all simply calls draw functions to draw the rest of the objects
        function drawAll() {
            drawItems();
            enemyDraw(en1);
            enemyDraw(en2);
        }


        //the update function calls other functions
        //these functions update the positions of the objects
        function update() {
            usrUpdate(pac);
            pinkGhostUpdate(en1);
            redGhostUpdate(en2);
        }

        //usrUpdate takes in a character object
        //this object will always be pacman, but incase i would want to turn this into multiplayer at a later date
        //it takes the objcet rather than calling the object directly
        function usrUpdate(pac) {
            //possMove is the move that pacman wants to move to
            var possMove;
            //bool is just a generic boolean
            var bool;
            //determines which axis to alter
            //if ySpeed is 0 then xSpeed will have a value
            // and vice versa
            if (pac.speed.x != 0) {
                //chk the space to the left or right   
                //possmove is now calculated by doing the math that will occur if the move is good
                possMove = pac.position.x + pac.speed.x;
                //creating 2 objects, one with the current position and one with the coordinates of the next move
                var pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                var pos1 = {
                    y: pac.position.y,
                    x: possMove
                };

                //chkVertMapColl will chk if the possible position is a good one or not
                bool = chkVertMapColl(pos, pos1);

                //this else statement is effectively the same as above, the only difference 
                //is that it affects the y coordinates rather than the x coordinates
            } else if (pac.speed.y != 0) {
                //chk the space up or down   
                possMove = pac.position.y + pac.speed.y;
                var pos = {
                    y: pac.position.y,
                    x: pac.position.x,
                    name: pac.type
                };
                var pos1 = {
                    y: possMove,
                    x: pac.position.x
                };
                bool = chkVertMapColl(pos, pos1);
            }

            /*
                MAKES MORE SENSE LOGICALLY TO RETURN A TRUE IF 
                MOVE IS VALID
                
                CHANGE THIS!
            
            */
            //the function returns a TRUE if the move is valid
            if (bool == false) {
                //as long as the move is valid, it will update the position
                //the amount of the speed
                pac.position.x += pac.speed.x;
                pac.position.y += pac.speed.y;
            }
        }

        //this function loops through the array, it first finds the row of the current pacman position
        //it then searches through that column to find the row
        function getMapPos(curPos, possPos) {
            for (mapPos = 0; mapPos < boundYSortArr.length; ++mapPos) {
                //if the column is not correct, add a the length of a row to mapPos so that it gets the next row 
                if (curPos.y != boundYSortArr[mapPos].y) {
                    mapPos += mapArray[1].length - 1;
                    //to get to this part of the code, the search would have to find the row of pacman
                    //at this point, we search through this row to find it's exact location
                } else if (curPos.x == boundYSortArr[mapPos].x) {
                    //found currunt position at this point

                    //setPossDifference alters mapPos so that it represents the
                    //coOrdinates of the position to be moved to
                    mapPos = setPossDifference(curPos, possPos, mapPos);

                    //this returned position is returned to the parent function
                    return mapPos;
                }
            }
        }

        function setPossDifference(curPos, possPos, mapPos) {

            //posDiff checks x value and y value of curPos and possPos
            //it returns an 'x' if the x positions are different and a 'y' if the ys are different
            if (posDiff(curPos, possPos) == 'x') {
                //a check to see in what way are they different
                //if current is bigger than potential, then pacman wants to move right
                if (curPos.x > possPos.x) {
                    mapPos--;
                    //otherwise pacman wants to move left
                } else if (curPos.x < possPos.x) {
                    mapPos++;
                }
                //if 'x' wasnt return than it has to be the y that is different
                //in this case pacman wants to move up or down
            } else {
                //if up then pacman needs to shift the length of a row in the 2-dim array
                if (curPos.y > possPos.y) {
                    mapPos -= mapArray[0].length;
                    //otherwise he needs to shift back the same length as he is going down
                } else {
                    mapPos += mapArray[0].length;
                }
            }
            //at this point, the position that pacman wants to move in is known in the array
            //so that position is returned
            return mapPos;
        }

        //simple update score function
        //takes in a value and adds it to the score
        function updateScore(i) {
            score += i;
        }

        //simply changes the type of the block
        //takes in the position of the array and the new value on that position's type
        function changeMapType(pos, newT) {
            boundYSortArr[pos].type = newT;
        }


        //chkMapNoType takes in the current position, the value in the array of the possible move
        function chkMapNoType(i, curPos) {

            //checks are made to see if the possible move is a barrier  
            //i.e it's not a food or eaten food
            if ((boundYSortArr[i].type != 0) && (boundYSortArr[i].type != 3) && (boundYSortArr[i].type != 10)) {

                //if this is entered, then the move is invalid immediately
                //this is a barrier       

                /*
                    SWAP TRUE AND FALSE TO MAKE MORE SENSE
                */
                //a boolean is returned here stating that the position is invalid
                return true;
                //if the position is a food place it is valid for all characters to move to
            } else {
                //if pacman is the current character
                //the food will need to be eaten
                //the food state will need to change to eaten
                //and the score will need to be updated
                if (curPos.name == "pac") {
                    if (boundYSortArr[i].type == 0) {
                        boundYSortArr[i].type = 3;
                        changeMapType(i, 3);
                        updateScore(1);
                    }
                    //a check here tries to determine if the block is possibly a portal
                    //if it is then code needs to address that
                    if (boundYSortArr[i].type == 10) {
                        //at this point, it is known that it is a portal
                        //we now need to see if it is a portal on the left or the right
                        //if on the left, we need to jump pacman to the far right hand side
                        if (boundYSortArr[i].x <= 30) {
                            pac.position.x = 970;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i + mapArray[1].length - 2].type == 0) {
                                changeMapType(i + mapArray[1].length - 2, 3);
                                //score is updated also
                                updateScore(1);
                            }
                            //if the portal is not on the left then it is on the right
                            //the pacman's position will need to be changed
                        } else {
                            pac.position.x = 30;

                            //a check on the state of the food at the other side of the portal is done
                            //an error occurs when entering portals where the first food is not eaten
                            //this checks that and makes sure that it is eaten
                            if (boundYSortArr[i - mapArray[1].length + 3].type == 0) {
                                changeMapType(i - mapArray[1].length + 3, 3);
                                updateScore(1);
                            }
                        }
                    }
                }
            }

            //a boolean is returned here indicating that the position is valid
            return false;
        }

        function chkVertMapColl(curPos, possPos) {

            //getMapPos will return the value of the position in the array that the character wants to move to
            var i = getMapPos(curPos, possPos);

            //if we are dealing with pacman, then the current pos needs to be updated
            //a boolean is returned, indicating the legibilty of the proposed move
            var bool = chkMapNoType(i, curPos);
            if (curPos.name == "pac" && bool == false) {
                pac.currPos = i;
            }
            return bool;
        }

        //posDiff takes in two position objects
        //it will check if the x or the y positions are different
        function posDiff(curPos, possPos) {
            //x is different
            if (curPos.x != possPos.x) {
                return 'x';
            }
            //y is different
            else {
                return 'y';
            }
        }


        //this function is effectively the AI of the ghost
        function redGhostUpdate(en) {
            var bool = true;

            /*
            
                MAKE ENMYDISTCS RETURN A VALUE
                ENEMY WILL UPDATE LATER ON
            
            */
            // while (bool == true) {

            enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y, en);

            if (en.speed.x != 0) {
                //chk the space to the left or right   
                possMove = en.position.x + en.speed.x;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: en.position.y,
                    x: possMove
                };
                bool = chkVertMapColl(pos, pos1);
            } else if (en.speed.y != 0) {
                //chk the space up or down   
                possMove = en.position.y + en.speed.y;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: possMove,
                    x: en.position.x
                };
                bool = chkVertMapColl(pos, pos1);
            }
            if (bool == false) {
                en.position.x += en.speed.x;
                en.position.y += en.speed.y;
            }
            return bool;
        }

        //this function is the AI of the pink ghost
        function pinkGhostUpdate(en) {
            if (scatterMode == true) {
                //scatter!   
            } else {
                if (recalcDirec == true) {
                    var numAhead = 90;
                    
                    if (pac.speed.x > 0) {
                        enemyDistances(en.position.x, en.position.y, pac.position.x + numAhead, pac.position.y, en);
                    } else if (pac.speed.x < 0) {
                        enemyDistances(en.position.x, en.position.y, pac.position.x - numAhead, pac.position.y, en);
                    } else if (pac.speed.y > 0) {
                        enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y + numAhead, en);
                    } else {
                        enemyDistances(en.position.x, en.position.y, pac.position.x, pac.position.y - numAhead, en);
                    }
                    recalcDirec = false;
                }
                enNormalMode(en);
            }

            if (enemyTurnCount >= 20) {
                scatterMode = true;
                
                /*
                
                    TEMPORARY SOLUTION TO SCATTERMODE FOR TESTING PURPOSES
                
                */
                enemyTurnCount++;
            }
            if (enemyTurnCount == 25) {
                scatterMode = false;
                enemyTurnCount = 0;
            }

        }

        function scatterMode(en) {

        }

        function enNormalMode(en) {
            var bool = true; 
            var possMove;

            if (en.speed.x != 0) {
                //chk the space to the left or right   
                possMove = en.position.x + en.speed.x;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: en.position.y,
                    x: possMove
                };
                bool = chkVertMapColl(pos, pos1);
            } else if (en.speed.y != 0) {
                //chk the space up or down   
                possMove = en.position.y + en.speed.y;
                var pos = {
                    y: en.position.y,
                    x: en.position.x,
                    name: en.type
                };
                var pos1 = {
                    y: possMove,
                    x: en.position.x
                };
            }
                
                enemyTurnCount++;
                bool = chkVertMapColl(pos, pos1);
                if ((enemyTurnCount % 5 == 0) || bool == true || (oldX != pac.speed.x || oldY != pac.speed.y)) {
                    //every 5th turn, or if the ghost is at a barrier or if the user changes directions
                    //the ghost needs to recalculate its direction
                    recalcDirec = true;
                    if (oldX != pac.speed.x) {
                        oldX = pac.speed.x;
                    }
                    if (oldY != pac.speed.y) {
                        oldY = pac.speed.y;
                    }
            }
            if (bool == false) {
                en.position.x += en.speed.x;
                en.position.y += en.speed.y;
            }
            return bool;
        }
        

        function scatterMode() {

        }

        function enemyDraw(en) {
            ctx.beginPath();
            if (en == en1) {
                ctx.fillStyle = "rgb(240,150,240)";
            } else {
                ctx.fillStyle = "rgb(240,0,17)";
            }
            ctx.arc(en.position.x, en.position.y, 15, 0, 2 * Math.PI, false);
            ctx.fill();

            ctx.closePath();
        }

        //this function calculates which direction is faster than the others for the AI to reach pacman
        function enemyDistances(eX, eY, usrX, usrY, en) {
            //initializing the directions to infinity
            //this will ensure that if they are not valid options
            //they will not be counted
            var up = Infinity,
                left = Infinity,
                right = Infinity,
                down = Infinity,
                min = 0;
            //creating a currPos object that stores the current position of the ghost
            //it also stores the fact that it is an enemy
            var currPos = {
                y: en.position.y,
                x: en.position.x,
                name: en.type
            };

            var upPos = {
                y: eY - 10,
                x: eX
            };
            var downPos = {
                y: eY + 10,
                x: eX
            };
            var leftPos = {
                y: eY,
                x: eX - 10
            };
            var rightPos = {
                y: eY,
                x: eX + 10
            };


            //here the possible positions are checked
            //using the distance of a line formula
            //the direction with the shortest distance will be chosen

            //chose to nest the call on chkVertMapColl inside an initial if statement
            //for a more efficient calculation

            if (!chkVertMapColl(currPos, upPos)) {
                up = dist(eX, eY - 10, usrX, usrY);
            }

            if (!chkVertMapColl(currPos, downPos)) {
                down = dist(eX, eY + 10, usrX, usrY);
            }
            if (pac.position.x > en.position.x) {
                if (!chkVertMapColl(currPos, rightPos)) {
                    right = dist(eX + 10, eY, usrX, usrY);
                }
            }
            if (pac.position.x < en.position.x) {
                if (!chkVertMapColl(currPos, leftPos)) {
                    left = dist(eX - 10, eY, usrX, usrY);
                }
            }

            /*
                CHECK IF SCATTER MODE
                IF SCATTER MODE GRAB MATH.MAX
                ALSO YOU'D NEED TO SET THE INITIAL VALUES TO 0 INSTEAD OF INFINITY
            */
            //math.min selects the smallest distance
            min = Math.min(up, down, right, left);

            //calcEnMove will compare the distances with the min value
            //it will then move in that direction
            calcEnMove(up, down, right, left, min, en);
        }

        //basic distance of a line formula
        function dist(enX, enY, usrX, usrY) {
            var b1 = enX - usrX;
            b1 = Math.pow(b1, 2);
            var b2 = enY - usrY;
            b2 = Math.pow(b2, 2);
            return Math.sqrt(b1 + b2);
        }

        //checks which distance is min
        //whichever it is then it moves in that direction
        function calcEnMove(u, d, r, l, min, en) {
            if (u == min) {
                en.speed.x = 0;
                en.speed.y = -20;
            } else if (d == min) {
                en.speed.x = 0;
                en.speed.y = 20;
            } else if (r == min) {
                en.speed.x = 20;
                en.speed.y = 0;
            } else {
                en.speed.x = -20;
                en.speed.y = 0;
            }
        }

        //this function takes in the 2-dim array
        //and converts it to an object 1 dim array, containing x, y positions for each square in the grid
        //it also will contain the type of square that it is
        function popAccBoundArr() {
            var x = 20,
                y = 10;
            for (var i = 0; i < mapArray.length; ++i) {
                var inner = mapArray[i];
                y += 20;
                x = 30;
                for (var j = 0; j < inner.length; ++j) {
                    var outer = inner[j];
                    sortBoundaries(outer, x, y, boundYSortArr);
                    x += 20;
                }
            }
        }

        //this function creates a new array element with the passed in object parameters
        function sortBoundaries(type, x, y, arr) {
            arr.push({
                type, x, y
            });
        }

        //this function reads the object array of grid squares
        //it then draws an object in the correct grid based on it's type
        function drawItems() {
            for (var i = 0; i < boundYSortArr.length; ++i) {
                switch (boundYSortArr[i].type) {

                    //food
                case 0:
                    ctx.beginPath();
                    ctx.fillStyle = "rgb(9,245,0)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 3, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0;
                    ctx.fill();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.closePath();
                    break;

                    //circles
                case 1:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(24,202,230)";
                    ctx.arc(boundYSortArr[i].x, boundYSortArr[i].y, 10, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    // verticle side
                case 2:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 20);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 20);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //eaten food
                case 3:
                    break;

                    //top left corner
                case 4:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //top right corner
                case 5:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y + 10);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //horizontal line
                case 6:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x - 20, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x + 20, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //bottom left Corner
                case 7:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x + 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                    //bottom right corner    
                case 8:
                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x, boundYSortArr[i].y - 10);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.strokeStyle = "rgb(255,0,255)";
                    ctx.moveTo(boundYSortArr[i].x - 10, boundYSortArr[i].y);
                    ctx.lineTo(boundYSortArr[i].x, boundYSortArr[i].y);
                    ctx.stroke();
                    ctx.closePath();
                    break;

                    //end of line
                case 9:
                    break;

                    //portals
                case 10:
                    break;
                }

                ctx.strokeStyle = "rgb(0,0,0)";
            }
        }
    </script>

</body>

</html>